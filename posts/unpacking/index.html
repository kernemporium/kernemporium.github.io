<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Automatic unpacking with Qiling framework :: kernemporium</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Welcome folks, today I want to show you a few tricks about automatic unpacking on elf executables with qiling framework !
EDIT: This Write-Up is working only with a particular (and ancient) version of the qiling framwork. So if you want a full working poc, run the final script in my docker image.
Introduction to automatic unpacking The automatic unpacking is the art of extracting certain informations from an obfuscated executable, to subsquently make another binary more easily readable." />
<meta name="keywords" content="RE, pwn, ctf, kernel" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/unpacking/" />




<link rel="stylesheet" href="/assets/style.css">






<link rel="apple-touch-icon" href="/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Automatic unpacking with Qiling framework">
<meta property="og:description" content="Welcome folks, today I want to show you a few tricks about automatic unpacking on elf executables with qiling framework !
EDIT: This Write-Up is working only with a particular (and ancient) version of the qiling framwork. So if you want a full working poc, run the final script in my docker image.
Introduction to automatic unpacking The automatic unpacking is the art of extracting certain informations from an obfuscated executable, to subsquently make another binary more easily readable." />
<meta property="og:url" content="/posts/unpacking/" />
<meta property="og:site_name" content="kernemporium" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-03-31 00:00:00 &#43;0000 UTC" />












</head>
<body class="orange">


<div class="container full headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    kernemporium
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/whoami/whoami">about</a></li>
        
      
        
          <li><a href="/heap">heap</a></li>
        
      
        
          <li><a href="/kernel">kernel</a></li>
        
      
      
    

    
    <div class="spacer"></div>
    <ul class="language-selector">
      <ul class="language-selector-current">
          <li>English ‚ñæ</li>
      </ul>
      <ul class="language-selector__more hidden">
        
        <li><a href="/">English</a></li>
        
        <li><a href="/fr/">Fran√ßais</a></li>
        
      </ul>
    </ul>
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/whoami/whoami">about</a></li>
      
    
      
        <li><a href="/heap">heap</a></li>
      
    
      
        <li><a href="/kernel">kernel</a></li>
      
    
    
    <hr />
      
        <li>
          <a href="/">English</a>
        </li>
      
        <li>
          <a href="/fr/">Fran√ßais</a>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/unpacking/">Automatic unpacking with Qiling framework</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-03-31 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/unpacking/">unpacking</a>&nbsp;
    
    #<a href="/tags/qiling/">qiling</a>&nbsp;
    
    #<a href="/tags/elf/">elf</a>&nbsp;
    
    #<a href="/tags/mmap/">mmap</a>&nbsp;
    
    #<a href="/tags/obfuscation/">obfuscation</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <p>Welcome folks, today I want to show you a few tricks about automatic unpacking on elf executables with <a href="https://github.com/qilingframework/qiling">qiling framework</a> !</p>
<p>EDIT: This Write-Up is working only with a particular (and ancient) version of the qiling framwork.
So if you want a full working poc, run the final script in my <a href="https://hub.docker.com/repository/docker/nasmre/rebox">docker image</a>.</p>
<h2 id="introduction-to-automatic-unpacking">Introduction to automatic unpacking<a href="#introduction-to-automatic-unpacking" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The automatic unpacking is the art of extracting certain informations from an obfuscated executable, to subsquently make another binary more easily readable. A native binary can be obfuscated in a lot ways, including: (virtual machine based obfuscation, opaque predicates, polymorphism &hellip;), and we will not always be able to deobfuscate the targeted binary. But it&rsquo;s very hard for an obfuscator to keep the same behavior and to in the same time obfuscate directly the code of the original binary. Indeed there are many parameters which are hard to predict (indirect jmp &hellip;). That is why quite often the obfuscator is working &ldquo;around&rdquo; the targeted binary. It means that instead of editing the structure of the binary, it apply certain techniques to make it very difficult to comprehend the structure of the binary, often by packing. The goal for the usage of automatically unpacking an obfuscated executable, is to search a state within the executable where the code (and all the structure of the binary if we are lucky) are unpacked. But finally what is packing / unpacking?</p>
<h2 id="how-does-packing-work">How does Packing work<a href="#how-does-packing-work" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Basically, the term &ldquo;packing&rdquo; refers to certain techniques used by an external program on a targeted executable for reducing it&rsquo;s length size, with some compression algorithms as an example. Then they will have to inject a small &ldquo;stub&rdquo; somewhere in the binary, which is just a piece of code within the binary, that will just decompress / unpack at runtime the packed binary and finally jumping on the Original Entry Point (OEP). The properties of such programs are very essential and useful for obfuscation, because it prevents a program from being statically analysed. However, the unpacking stub which will decipher and jump on the OEP is readable (in a disassembler). The concept of ciphering the code of an executable, injecting an unpacking stub and jump on the OEP is very simple, but how does it really work?</p>
<h2 id="code-injection--common-techniques">Code injection &amp; common techniques<a href="#code-injection--common-techniques" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>For this article, I will only be focusing on the elf executable format. So, we can distinguish a few techniques just by checking how the unpacking stub is injected. It will determine how the file is unpacked. We can distinguish two main families:</p>
<ul>
<li>The obfuscator keeps the structure of the original binary and inject an unpacking stub either in the code cave (memory area at the end of the executable PT_LOAD segment unused for alignment purposes) or it injects the unpacking stub at the end of the last PT_LOAD segment and edit the permissions of this segment by adding PF_X (executable) flag to its program header. In the injected code, it is only needed to be able to write on the packed data, so either the permissions of the target segment contain the PF_W flag or the injected payload edits directly the permissions at runtime with mprotect.</li>
</ul>

  <img src="/first_shm.png"  alt="elf"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>The only drawback of injecting the unpacking stub in the code cave is has a finite length and will be different on each binaries. So the better technique would be to inject the unpacking stub at the end of the last PT_LOAD often with PF_R | PF_W permissions. The algorithm is quite simple and is explained in detail <a href="http://index-of.es/Varios-2/Learning%20Linux%20Binary%20Analysis.pdf">here</a>. From a reverser point of view, we just need to understand that the EP is replaced by the address of the injected code. Of course, there are a lot of ways to inject code in an elf file, not only by expanding the length size of the last PT_LOAD. But they are similar and at a state of the execution, they will always jump at the OEP for executing the original binary. The main difference with the second technique is that the unpacking stub is just a parasite code which must not impact the execution of the original binary (if the program handles data relatively with an offset or directly a virtual address and that they are edited by the injection of the stub it will produce a crazy behavior).</p>
<ul>
<li>The obfuscator creates a new binary where it will keep a packed / ciphered version of the binary in a section (.data, .rodata it depends to the implementation). It&rsquo;s an entirely new binary and the executable code has just to: [1] unpack the ciphered binary [2] Extract informations from the executable header and from the program header table, and with these informations map the binary either by creating a new process or by mapping the binary in its own address space. Especially by using functions like mmap with MAP_FIXED argument for maping the binary at a particular location. [3] Then when the binary is completely loaded into memory, it has to jmp (often with an indirect jump) at the address of the OEP and the execution will continue without any problems. This technique is very interesting because you can heavily obfuscate the loader and don&rsquo;t care to the impact of the code injection. But it&rsquo;s a bit more complicated to implement if you want to cover all kind of binaries. Indeed when the binary isn&rsquo;t statically linked, you have to map the dynamic linker somewhere in the process. Finally your goal is to load the binary in the same way as the kernel so it&rsquo;s not always easy :) .</li>
</ul>

  <img src="/scnd_shm.png"  alt="process"  class="left"  style="margin-left: auto; margin-right: auto"  />


<center>Basic schema of a loader</center>
<p>The schema is very basic and there is a lot of ways to go about loading a binary manually into memory so I will stay succinct. Firstly, the execution begins in the loader which will either unpack the header of the packed binary or directly extract the informations from the headers if it there are not ciphered. The needed informations to iterate through all the program headers and to store the original entry point are the e_phentsize, e_phnum and the e_entry fields of the elf header.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* /usr/include/elf.h */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> e_ident[EI_NIDENT];     <span style="color:#75715e">/* Magic number and other info */</span>
  Elf64_Half    e_type;                 <span style="color:#75715e">/* Object file type */</span>
  Elf64_Half    e_machine;              <span style="color:#75715e">/* Architecture */</span>
  Elf64_Word    e_version;              <span style="color:#75715e">/* Object file version */</span>
  Elf64_Addr    e_entry;                <span style="color:#75715e">/* Entry point virtual address */</span>
  Elf64_Off     e_phoff;                <span style="color:#75715e">/* Program header table file offset */</span>
  Elf64_Off     e_shoff;                <span style="color:#75715e">/* Section header table file offset */</span>
  Elf64_Word    e_flags;                <span style="color:#75715e">/* Processor-specific flags */</span>
  Elf64_Half    e_ehsize;               <span style="color:#75715e">/* ELF header size in bytes */</span>
  Elf64_Half    e_phentsize;            <span style="color:#75715e">/* Program header table entry size */</span>
  Elf64_Half    e_phnum;                <span style="color:#75715e">/* Program header table entry count */</span>
  Elf64_Half    e_shentsize;            <span style="color:#75715e">/* Section header table entry size */</span>
  Elf64_Half    e_shnum;                <span style="color:#75715e">/* Section header table entry count */</span>
  Elf64_Half    e_shstrndx;             <span style="color:#75715e">/* Section header string table index */</span>
} Elf64_Ehdr;

<span style="color:#75715e">/* Structure of the executable header */</span>
</code></pre></div><p>Then while iterating through all the program headers, it will proceed to check if p_type is equal to
PT_LOAD if it is, it will make a <code>mmap(p_vaddr, p_memsz, p_flags, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0x0);</code> in order to setup a memory area for each segment. The PT_LOAD segments are the segments which are needed for the execution, they group the different sections / segments in the binary
with the same permissions. That&rsquo;s why the sections with the same access permissions are
next to each other in an ELF. On a pie based binary (random base address) the p_vaddr (virtual address) field in the program header of a PT_LOAD segment is equivalent to its offset in the file and all the jmp &amp; data handling are done relatively by using rip (the instruction pointer), the binary can therefore be mmaped everywhere.  For the others executables which have a defined base address it must mmap the segments of the binary from a particular base address often 0x400000.
We can then use the MAP_FIXED argument to mmap a segment at a particular location. Next the mmap it has just to make a <code>write(mmap_addr, .rodata + p_offset, p_filesz);</code> (assuming the binary is located in the .rodata). And if the binary is dynamically linked it will take a look at the the PT_INTERP segment for extracting the pathname of the dynamic linker in order to parse its headers and to mmap all the segments in the same way that the original binary. When it&rsquo;s done, the loader will just edit a few fields on the stack: argv[0] *(rsp+8) field by the pathname of the original binary, and the following auxiliary vectors on the stack AT_PHDR, AT_PHENT, AT_PHNUM, AT_BASE (base address of interpreter), AT_ENTRY (OEP) according to the informations in the original executable header. The auxiliary vectors are just structures on the stack which display informations about the program, the system and certain fields that are mandatory for the dynamic linkers. Finally, if the binary is statically linked it will jump at the OEP or at the entry point of the dynamic linker with all the registers set to 0x0 except rsp &amp; rip :)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">/* /usr/include/elf.h */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
  Elf64_Word    p_type;                 <span style="color:#75715e">/* Segment type */</span>
  Elf64_Word    p_flags;                <span style="color:#75715e">/* Segment flags */</span>
  Elf64_Off     p_offset;               <span style="color:#75715e">/* Segment file offset */</span>
  Elf64_Addr    p_vaddr;                <span style="color:#75715e">/* Segment virtual address */</span>
  Elf64_Addr    p_paddr;                <span style="color:#75715e">/* Segment physical address */</span>
  Elf64_Xword   p_filesz;               <span style="color:#75715e">/* Segment size in file */</span>
  Elf64_Xword   p_memsz;                <span style="color:#75715e">/* Segment size in memory */</span>
  Elf64_Xword   p_align;                <span style="color:#75715e">/* Segment alignment */</span>
} Elf64_Phdr;

<span style="color:#75715e">/* Structure of the program header */</span>

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  <span style="color:#75715e">/* /usr/include/elf.h */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
  uint32_t a_type;              <span style="color:#75715e">/* Entry type */</span>
  <span style="color:#66d9ef">union</span> {
      uint32_t a_val;           <span style="color:#75715e">/* Integer value */</span>
    } a_un;
} Elf32_auxv_t;

  <span style="color:#75715e">/* Elf32_auxv_t; */</span>

  <span style="color:#75715e">/* /usr/include/auxvec.h */</span>

<span style="color:#75715e">#define AT_NULL   0	</span><span style="color:#75715e">/* end of vector */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_IGNORE 1	</span><span style="color:#75715e">/* entry should be ignored */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_EXECFD 2	</span><span style="color:#75715e">/* file descriptor of program */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_PHDR   3	</span><span style="color:#75715e">/* program headers for program */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_PHENT  4	</span><span style="color:#75715e">/* size of program header entry */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_PHNUM  5	</span><span style="color:#75715e">/* number of program headers */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_PAGESZ 6	</span><span style="color:#75715e">/* system page size */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_BASE   7	</span><span style="color:#75715e">/* base address of interpreter */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_FLAGS  8	</span><span style="color:#75715e">/* flags */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_ENTRY  9	</span><span style="color:#75715e">/* entry point of program */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_NOTELF 10	</span><span style="color:#75715e">/* program is not ELF */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_UID    11	</span><span style="color:#75715e">/* real uid */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_EUID   12	</span><span style="color:#75715e">/* effective uid */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_GID    13	</span><span style="color:#75715e">/* real gid */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define AT_EGID   14	</span><span style="color:#75715e">/* effective gid */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
</code></pre></div><center>More about auxiliary vectors and elf loading can be found [here](https://www.gabriel.urdhr.fr/2015/01/22/elf-linking/).</center>
<p>Now that we have a basic understanding of what are the most common techniques of packing, I think it&rsquo;s important to figure out and to keep in consideration that in reality we will be dealing often with some variants of these techniques. For example, an obfuscator can implement a few layers of packing by unpacking a binary which will unpack another binary &hellip; Or unpack a part of the unpacking stub. Furthermore, packing is almost always associated with anti-debug/anti-disassembly techniques. Finally, the weak point of packing / unpacking is that it&rsquo;s crucial that at runtime the whole or a big part of the original binary is in clear in memory. But we can imagine that if the binary is instrumented, only a small part is deciphered at runtime. For example, the injected payload can unpack only the first few bytes of the target executable, evaluate the first instruction by disassembling it, inserting a hook just after and save the bytes erased by the hook. Next it has to jump at the OEP, execute the first instruction, reach the hook and go back to repeat cycle for the next instruction. So even if most of the time, packing &amp; polymorphism are very easy to implement and to analyse, you can make things a bit more complicated to detect and to analyse for a Reverse Engineer. The only limit is your imagination üôÉ.</p>
<h2 id="unpacking-thougths--algorithms">Unpacking, thougths &amp; algorithms<a href="#unpacking-thougths--algorithms" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now that we know the behavior of most of polymorphic engines, we can proceed to establish a few conditions on which we can automatically detect a polymorphic behavior:</p>
<ul>
<li>
<p>A write in a writable and executable area and potentially a jump in this area (page granularity, length size of a page: 0x1000). We can conclude that the other executable pages next to this page which have been written are suspicious.</p>
</li>
<li>
<p>A call to mprotect, with the exec | write and read permissions are as seen above to trace and potentially to dump at a particular state of the execution.</p>
</li>
<li>
<p>A call to mmap with PROT_EXEC | PROT_WRITE | PROT_READ protections are also interesting and as seen in the manual mapping part the mapping of the target binary implies always the usage of mmap syscall.</p>
</li>
<li>
<p>A <code>jmp &lt;reg&gt;</code> instruction where reg contains the adress of an area either mprotect-ed with the PROT_EXEC | PROT_WRITE | PROT_READ flags or a mmaped area with the same protections. But it can be summed up by one rule: an indirect jmp in an executable area mapped by our program are suspecious and should be considerably acknowledge.</p>
</li>
</ul>
<p>Now that we know exactly how to detect most of the packing techniques, we have another problem, the more complete the analysis, the more false-positive we get. Unavoidably, the analyse will take a looooooot of time. That&rsquo;s why for our automatic unpacker, we will just check that the execution was in an executable area mmaped by the program üë®üèª‚Äçüíª. And if it is the case we will either looking for an elf header or just dump the whole page.</p>
<h2 id="qiling-the-future-of-binary-analysis">Qiling, the future of binary analysis<a href="#qiling-the-future-of-binary-analysis" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The <a href="https://qiling.io/">Qiling framework</a> is an awesome binary emulation / instrumentation framework ! It&rsquo;s based on the <a href="https://www.unicorn-engine.org/">Unicorn engine</a> and groups all the qualities of a virtual machine based sandbox but without any iso . Indeed, it emulates directly the kernel of many operating systems ( Windows X86 32/64, Linux X86 32/64, ARM, AARCH64, MIPS, MacOS X86 32/64, FreeBSD X86 32/64 and even UEFI !! ). A big part of the syscalls are reimplemented and it deludes the executable into thinking it&rsquo;s actually being executing into a real operating system. It&rsquo;s based on a virtual file system called rootfs which is easy to handle. As an example, if a library (.so or .dll) is missed you will have just to append it in the corresponding rootfs. The framework is developped in python(3), it&rsquo;s a very young and nice project, so feel free to contribute. Furthermore, there is a lot of unimplemented functions and to reimplement these you have just to understand how they work, develop your implementation in python and hook the call of these functions. If it works great, integrate them to the core and make a pull request üß†. On this side, qiling is very interesting because it lets you to have a better understanding of the kernel. With qiling you can litterally hook everythings according to <a href="https://docs.qiling.io/en/latest/hook/">the documentation</a>. Very useful for automatic unpacking !!</p>
<h2 id="first-approach-with-qiling">First approach with qiling<a href="#first-approach-with-qiling" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>To install the qiling framework you can either directly use the docker image developped by qiling <a href="https://github.com/qilingframework/qiling/blob/master/Dockerfile">here</a> or install my docker image which groups an environment oriented RE / vuln research by typing <code>docker pull nasmre/rebox:latest</code>. For the needs of the article I will work on a crackme developped by <a href="http://aassfxxx.infos.st/">@aassfxxx</a> ! The structure of program using qiling looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#75715e"># author: nasm</span>

<span style="color:#f92672">import</span> sys

sys<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;../&#34;</span>)
<span style="color:#75715e"># Specification of the qiling&#39;s directory (mandatory)</span>

<span style="color:#f92672">from</span> qiling <span style="color:#f92672">import</span> Qiling
<span style="color:#75715e"># [1]</span>

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    _ql_ <span style="color:#f92672">=</span> Qiling([<span style="color:#e6db74">&#34;rootfs/x8664_linux/bin/leetness&#34;</span>], <span style="color:#e6db74">&#34;rootfs/x8664_linux/&#34;</span>, output<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;debug&#34;</span>)
    <span style="color:#75715e"># [2]</span>

    _ql_<span style="color:#f92672">.</span>run()
    <span style="color:#75715e"># [3]</span>
</code></pre></div><p>In [1] we import the main part of the qiling engine which will return in [2] a ql object. This object is the base of all the qiling engine. It has especial run method which will just launch the emulation on the executable gived to Qiling in [2] with the file system specified in second argument. For this article, we will work on a real world crackme which is using composed of a loader and a ciphered binary. And as shown below the basic qiling&rsquo;s analysis does not work properly.</p>
<pre><code>[+] load 0x400000 - 0x401000
[+] load 0x7ff13371000 - 0x7ff1337e000
[+] load 0x7ff1337e000 - 0x7ff13383000
[+] load 0x7ff13383000 - 0x7ff13385000
[+] mem_start: 0x400000 mem_end: 0x7ff13385000
[+] mmap_address is : 0x7fffb7dd6000
open(/proc/self/exe, 0x0, 0o0) = -2
[+] open(/proc/self/exe, O_RDONLY, 0o0) = -2
[!] File Not Found /proc/self/exe
lseek(4294967294, 0x0, 0x2) = 0
[!] Syscall ERROR: ql_syscall_lseek DEBUG: list index out of range
Traceback (most recent call last):
  File &quot;article_qiling.py&quot;, line 15, in module
    ql.run()
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/core.py&quot;, line 197, in run
    self.os.run()
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/os/linux/linux.py&quot;, line 119, in run
    raise self.ql.internal_exception
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/utils.py&quot;, line 19, in wrapper
    return func(*args, **kw)
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/core_hooks.py&quot;, line 125, in _hook_insn_cb
    ret = h.call(ql, *args[ : -1])
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/core_hooks.py&quot;, line 34, in call
    return self.callback(ql, *args)
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/os/linux/linux.py&quot;, line 65, in hook_syscall
    return self.load_syscall(intno)
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/os/posix/posix.py&quot;, line 94, in load_syscall
    self.syscall_map(self.ql, self.get_func_arg()[0], self.get_func_arg()[1], self.get_func_arg()[2], self.get_func_arg()[3], self.get_func_arg()[4], self.get_func_arg()[5])
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/os/posix/syscall/unistd.py&quot;, line 142, in ql_syscall_lseek
    regreturn = ql.os.file_des[lseek_fd].lseek(lseek_ofset, lseek_origin)
</code></pre><p>Indeed, the executable is trying to open in O_RDONLY /proc/self/exe which corresponds to a symlink on itself. Being already mmaped, it can be opened only in O_RDONLY. For now qiling has not yet implemented the /proc interface, so we need to do it by hand. We can create the setup_self_proc function which will copy and rename the binary at the right location. We can&rsquo;t make a symlink because the open implementation of qiling cannot open the symbolic links.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#f92672">import</span> sys
sys<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling&#34;</span>)

<span style="color:#f92672">from</span> qiling <span style="color:#f92672">import</span> Qiling

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setup_self_proc</span>(exe_path : str, rootfs : str) <span style="color:#f92672">-&gt;</span> None:
  <span style="color:#66d9ef">with</span> open(rootfs <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;/proc/self/exe&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> file_created:
      file_created<span style="color:#f92672">.</span>seek(<span style="color:#ae81ff">0x0</span>)

      <span style="color:#66d9ef">with</span> open(exe_path, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> exe_file:
          data_exe <span style="color:#f92672">=</span> exe_file<span style="color:#f92672">.</span>read()

          file_created<span style="color:#f92672">.</span>write(data_exe)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    ql <span style="color:#f92672">=</span> Qiling([<span style="color:#e6db74">&#34;/mnt/p/leetness&#34;</span>], <span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling/examples/rootfs/x8664_linux&#34;</span>, output<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;debug&#34;</span>)
      
    setup_self_proc(<span style="color:#e6db74">&#34;/mnt/p/leetness&#34;</span>, <span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling/examples/rootfs/x8664_linux&#34;</span>)
      
    ql<span style="color:#f92672">.</span>run()
</code></pre></div><p>Now that it&rsquo;s fixed, let&rsquo;s launch again the script:</p>
<pre><code>[+] load 0x400000 - 0x401000
[+] load 0x7ff13371000 - 0x7ff1337e000
[+] load 0x7ff1337e000 - 0x7ff13383000
[+] load 0x7ff13383000 - 0x7ff13385000
[+] mem_start: 0x400000 mem_end: 0x7ff13385000
[+] mmap_address is : 0x7fffb7dd6000
open(/proc/self/exe, 0x0, 0o0) = 3
[+] open(/proc/self/exe, O_RDONLY, 0o0) = 3
[+] File Found: /proc/self/exe
lseek(3, 0x0, 0x2) = 0
lseek(3, 0x0, 0x2) = 79292
[+] log mmap2 - mmap2(0x0, 0x1e000, 0x3, 0x22, 4294967295, 0)
[+] log mmap2 - mmap2(0x0, 0x1e000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 4294967295, 0)
[+] log mmap2 - return addr : 0x7fffb7dd6000
[+] log mmap2 - addr range  : 0x7fffb7dd6000 - 0x7fffb7df4000
[+] log mmap2 - mapping needed
mmap2(0x0, 0x1e000, 0x3, 0x22, 4294967295, 0) = 0x7fffb7dd6000
[+] mmap2_base is 0x7fffb7dd6000
lseek(3, 0x0, 0x0) = 0
lseek(3, 0x0, 0x0) = 0
read(3, 0x7fffb7dd6028, 0x135bc) = 79292
[+] log mmap2 - mmap2(0x0, 0xc01000, 0x3, 0x22, 4294967295, 0)
[+] log mmap2 - mmap2(0x0, 0xc01000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 4294967295, 0)
[+] log mmap2 - return addr : 0x7fffb7df4000
[+] log mmap2 - addr range  : 0x7fffb7df4000 - 0x7fffb89f5000
[+] log mmap2 - mapping needed
mmap2(0x0, 0xc01000, 0x3, 0x22, 4294967295, 0) = 0x7fffb7df4000
[+] mmap2_base is 0x7fffb7df4000
[+] log mmap2 - mmap2(0x400000, 0x1000, 0x7, 0x32, 4294967295, 0)
[+] log mmap2 - mmap2(0x400000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, 4294967295, 0)
[+] log mmap2 - return addr : 0x400000
[+] log mmap2 - addr range  : 0x400000 - 0x401000
mmap2(0x400000, 0x1000, 0x7, 0x32, 4294967295, 0) = 0x400000
[+] mmap2_base is 0x400000
[!] Emulation Error

[-] rax :        0x400000
[-] rbx :        0x7fffb7df398c
[-] rcx :        0x0
[-] rdx :        0x17c
[-] rsi :        0x7fffb85f4040
[-] rdi :        0x400000
[-] rbp :        0x400000
[-] rsp :        0x80000000dc38
[-] r8  :        0x7f
[-] r9  :        0x0
[-] r10 :        0x32
[-] r11 :        0xbcf65a4b
[-] r12 :        0x80000000dd50
[-] r13 :        0x0
[-] r14 :        0x17c
[-] r15 :        0x80000000dca0
[-] rip :        0x7ff133725d8
[-] ef  :        0x0
[-] cs  :        0x1b
[-] ss  :        0x28
[-] ds  :        0x28
[-] es  :        0x28
[-] fs  :        0x0
[-] gs  :        0x0
[-] st0 :        0x0
[-] st1 :        0x0
[-] st2 :        0x0
[-] st3 :        0x0
[-] st4 :        0x0
[-] st5 :        0x0
[-] st6 :        0x0
[-] st7 :        0x0

[+] PC = 0x7ff133725d8
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT]
[+] 00400000 - 00401000 - r--    /mnt/p/leetness
[+] 7ff13371000 - 7ff1337e000 - r-x    /mnt/p/leetness
[+] 7ff1337e000 - 7ff13383000 - r--    /mnt/p/leetness
[+] 7ff13383000 - 7ff13385000 - rw-    /mnt/p/leetness
[+] 7ff13385000 - 7ff13387000 - rwx    hook mem
[+] 7fffb7dd6000 - 7fffb7df4000 - rwx    [mapped]
[+] 7fffb7df4000 - 7fffb89f5000 - rwx    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]

[+] ['0x31', '0xc9', '0x66', '0xf', '0x1f', '0x44', '0x0', '0x0']

[+] 0x7ff133725d8      31 c9 66 0f 1f 44 00 00 44 0f b6 04 0e 44 88 04 08 48 83 c1 01 48 39 ca 75 ee c3 66 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f9 4c 8d 04 3a 48 85 d2 74 0d 90 40 88 31 48 83 c1 01 49 
xor ecx, ecx
nop word ptr [rax + rax]
movzx r8d, byte ptr [rsi + rcx]
mov byte ptr [rax + rcx], r8b
add rcx, 1
cmp rdx, rcx
jne 0x7ff133725e0
ret
nop word ptr cs:[rax + rax]
nop
mov rax, rdi
mov rcx, rdi
lea r8, [rdx + rdi]
test rdx, rdx
je 0x7ff1337261c
nop
mov byte ptr [rcx], sil
add rcx, 1
Traceback (most recent call last):
  File &quot;article_qiling.py&quot;, line 26, in module
    ql.run()
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/core.py&quot;, line 197, in run
    self.os.run()
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/os/linux/linux.py&quot;, line 112, in run
    self.ql.emu_start(self.ql.loader.elf_entry, self.exit_point, self.ql.timeout, self.ql.count)
  File &quot;/usr/local/lib/python3.7/dist-packages/qiling-1.1a1-py3.7.egg/qiling/core.py&quot;, line 248, in emu_start
    self.uc.emu_start(begin, end, timeout, count)
  File &quot;/usr/local/lib/python3.7/dist-packages/unicorn/unicorn.py&quot;, line 317, in emu_start
    raise UcError(status)
unicorn.unicorn.UcError: Write to write-protected memory (UC_ERR_WRITE_PROT)
</code></pre><p>We are getting another crash because of the mmap implementation of mmap by qiling. In its implementation the requested blocks of memory (aligned on a page) are contiguous and each time a new block is requested a &ldquo;mmap base&rdquo; variable is incremented. Furthermore, It does not honor the permissions and is basically allocating all the blocks in RWX. Finally, the MAP_FIXED argument of mmap which is asking for a page at a particular virtual address is not supported. That&rsquo;s why we need to edit a little bit of the mmap implementation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#75715e"># https://github.com/qilingframework/qiling/blob/master/qiling/os/posix/syscall/mman.py</span>

<span style="color:#75715e"># Actual implementation</span>

<span style="color:#75715e"># =-=-=-=-=-=-=-=-=-=-=-=-=</span>

<span style="color:#75715e"># author: nasm</span>

<span style="color:#f92672">import</span> sys

sys<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling&#34;</span>)
<span style="color:#75715e"># Specification of the qiling&#39;s directory (mandatory)</span>

<span style="color:#f92672">from</span> qiling <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#75715e"># [1]</span>
<span style="color:#f92672">from</span> qiling.const <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#75715e"># QL_ARCH</span>
<span style="color:#f92672">from</span> qiling.os.posix.const_mapping <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#75715e"># mmap_prot_mapping</span>

<span style="color:#f92672">import</span> random
<span style="color:#75715e"># radom.choice</span>

<span style="color:#f92672">from</span> unicorn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#75715e"># UC_PROT_ALL</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_available</span>(ql, addr, size):
    <span style="color:#e6db74">&#39;&#39;&#39;
</span><span style="color:#e6db74">    The main function of is_available is to determine 
</span><span style="color:#e6db74">    whether the memory starting with addr and having a size of length can be used for allocation.
</span><span style="color:#e6db74">    If it can be allocated, returns True.
</span><span style="color:#e6db74">    If it cannot be allocated, it returns False.
</span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
    <span style="color:#66d9ef">try</span>:
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>map(addr, size)
    <span style="color:#66d9ef">except</span>:
        <span style="color:#66d9ef">return</span> False    

    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>unmap(addr, size)

    <span style="color:#66d9ef">return</span> True


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mmap_c</span>(ql, mmap2_addr, mmap2_length, mmap2_prot, mmap2_flags, mmap2_fd, mmap2_pgoffset):

    mmap2_length_align <span style="color:#f92672">=</span> ((mmap2_length <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>
    mmap2_addr_align <span style="color:#f92672">=</span> ((mmap2_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>

    ret <span style="color:#f92672">=</span> False

    <span style="color:#75715e"># this is ugly patch, we might need to get value from elf parse,</span>
    <span style="color:#75715e"># is32bit or is64bit value not by arch</span>

    MAP_ANONYMOUS<span style="color:#f92672">=</span><span style="color:#ae81ff">32</span>

    <span style="color:#66d9ef">if</span> (ql<span style="color:#f92672">.</span>archtype<span style="color:#f92672">==</span> QL_ARCH<span style="color:#f92672">.</span>ARM64) <span style="color:#f92672">or</span> (ql<span style="color:#f92672">.</span>archtype<span style="color:#f92672">==</span> QL_ARCH<span style="color:#f92672">.</span>X8664):
        mmap2_fd <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>unpack64(ql<span style="color:#f92672">.</span>pack64(mmap2_fd))

    <span style="color:#66d9ef">elif</span> (ql<span style="color:#f92672">.</span>archtype<span style="color:#f92672">==</span> QL_ARCH<span style="color:#f92672">.</span>MIPS):
        mmap2_fd <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>unpack32s(ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(mmap2_fd, <span style="color:#ae81ff">4</span>))
        mmap2_pgoffset <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>unpack32(ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(mmap2_pgoffset, <span style="color:#ae81ff">4</span>)) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4096</span>
        MAP_ANONYMOUS<span style="color:#f92672">=</span><span style="color:#ae81ff">2048</span>
    <span style="color:#66d9ef">else</span>:
        mmap2_fd <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>unpack32s(ql<span style="color:#f92672">.</span>pack32(mmap2_fd))
        mmap2_pgoffset <span style="color:#f92672">=</span> mmap2_pgoffset <span style="color:#f92672">*</span> <span style="color:#ae81ff">4096</span>

    <span style="color:#66d9ef">if</span> mmap2_addr <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>is_mapped(mmap2_addr, mmap2_length):
        ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - mmap2(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">)&#34;</span> <span style="color:#f92672">%</span> (
        mmap2_addr, mmap2_length, mmap2_prot, mmap2_flags, mmap2_fd, mmap2_pgoffset))
        ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - mmap2(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">)&#34;</span> <span style="color:#f92672">%</span> (
        mmap2_addr, mmap2_length, mmap_prot_mapping(mmap2_prot), mmap_flag_mapping(mmap2_flags), mmap2_fd, mmap2_pgoffset))
        ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - return addr : &#34;</span> <span style="color:#f92672">+</span> hex(<span style="color:#ae81ff">0x0</span>))

        ql<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>mem_protect(mmap2_addr_align, mmap2_length_align, mmap2_prot)

        local_hook(ql, mmap2_addr, mmap2_length_align, mmap2_prot)

        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>add_mapinfo(mmap2_addr, mmap2_addr <span style="color:#f92672">+</span> mmap2_length_align, mem_p <span style="color:#f92672">=</span> mmap2_prot, mem_info <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;[mapped]&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0x0</span>

    <span style="color:#66d9ef">if</span> mmap2_addr <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:

        <span style="color:#66d9ef">while</span> ret <span style="color:#f92672">==</span> False:
            random_base <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x00007fffffffffff</span>)

            random_base_align <span style="color:#f92672">=</span> ((random_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>

            ret <span style="color:#f92672">=</span> is_available(ql, random_base_align, mmap2_length_align)

    <span style="color:#66d9ef">else</span>:
        random_base_align <span style="color:#f92672">=</span> mmap2_addr_align

    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - mmap2(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">)&#34;</span> <span style="color:#f92672">%</span> (
    mmap2_addr, mmap2_length, mmap2_prot, mmap2_flags, mmap2_fd, mmap2_pgoffset))
    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - mmap2(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">)&#34;</span> <span style="color:#f92672">%</span> (
    mmap2_addr, mmap2_length, mmap_prot_mapping(mmap2_prot), mmap_flag_mapping(mmap2_flags), mmap2_fd, mmap2_pgoffset))
    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - return addr : &#34;</span> <span style="color:#f92672">+</span> hex(random_base_align))
    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mmap2 - addr range  : &#34;</span> <span style="color:#f92672">+</span> hex(random_base_align) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; - &#39;</span> <span style="color:#f92672">+</span> hex(
        random_base_align <span style="color:#f92672">+</span> mmap2_length_align))

    <span style="color:#66d9ef">try</span>:
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>map(random_base_align, mmap2_length_align)
    <span style="color:#66d9ef">except</span>:
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>show_mapinfo()
        <span style="color:#66d9ef">raise</span>

    ql<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>mem_protect(random_base_align, mmap2_length_align, UC_PROT_ALL)
    <span style="color:#75715e"># To avoid an invalid memory write</span>

    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>write(random_base_align, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> mmap2_length_align)

    <span style="color:#66d9ef">if</span> ((mmap2_flags <span style="color:#f92672">&amp;</span> MAP_ANONYMOUS) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">and</span> mmap2_fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">256</span> <span style="color:#f92672">and</span> ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>file_des[mmap2_fd] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
        ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>file_des[mmap2_fd]<span style="color:#f92672">.</span>lseek(mmap2_pgoffset)
        data <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>file_des[mmap2_fd]<span style="color:#f92672">.</span>read(mmap2_length)
        mem_info <span style="color:#f92672">=</span> str(ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>file_des[mmap2_fd]<span style="color:#f92672">.</span>name)

        ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mem write : &#34;</span> <span style="color:#f92672">+</span> hex(len(data)))
        ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] log mem mmap2  : &#34;</span> <span style="color:#f92672">+</span> mem_info)
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>add_mapinfo(random_base_align, random_base_align <span style="color:#f92672">+</span> (len(data)), mem_p <span style="color:#f92672">=</span> UC_PROT_ALL, mem_info <span style="color:#f92672">=</span> mem_info)
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>write(random_base_align, data)


    ql<span style="color:#f92672">.</span>nprint(<span style="color:#e6db74">&#34;mmap2(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">) = 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (mmap2_addr, mmap2_length, mmap2_prot, mmap2_flags, mmap2_fd, mmap2_pgoffset, random_base_align))

    regreturn <span style="color:#f92672">=</span> random_base_align
    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] mmap2_block is at 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74"> with a length of 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (regreturn, mmap2_length_align))

    ql<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>mem_protect(random_base_align, mmap2_length_align, mmap2_prot)

    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>add_mapinfo(random_base_align, random_base_align <span style="color:#f92672">+</span> mmap2_length_align, mem_p <span style="color:#f92672">=</span> mmap2_prot, mem_info<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;[mapped]&#34;</span>)
    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>show_mapinfo()

    ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>definesyscall_return(regreturn)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setup_self_proc</span>(exe_path : str, rootfs : str) <span style="color:#f92672">-&gt;</span> None:
  <span style="color:#66d9ef">with</span> open(rootfs <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;/proc/self/exe&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> file_created:
      file_created<span style="color:#f92672">.</span>seek(<span style="color:#ae81ff">0x0</span>)

      <span style="color:#66d9ef">with</span> open(exe_path, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> exe_file:
          data_exe <span style="color:#f92672">=</span> exe_file<span style="color:#f92672">.</span>read()

          file_created<span style="color:#f92672">.</span>write(data_exe)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    ql <span style="color:#f92672">=</span> Qiling([<span style="color:#e6db74">&#34;/mnt/p/leetness&#34;</span>], <span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling/examples/rootfs/x8664_linux&#34;</span>, output<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;debug&#34;</span>)

    setup_self_proc(<span style="color:#e6db74">&#34;/mnt/p/leetness&#34;</span>, <span style="color:#e6db74">&#34;/home/n4sm/Downloads/qiling/examples/rootfs/x8664_linux&#34;</span>)

    ql<span style="color:#f92672">.</span>set_syscall(<span style="color:#ae81ff">0x9</span>, mmap_c)
    <span style="color:#75715e"># [1]</span>

    ql<span style="color:#f92672">.</span>run()
</code></pre></div><p>In [1] we replace the syscall corresponding to the 0x9 syscall number (sys_mmap) by our implementation. The implementation is a bit different; however, the code is reasonably understandable with the comments. If you are not familiar with the <a href="https://github.com/torvalds/linux/blob/master/mm/mmap.c">mmap</a> syscall I advise you to read either <a href="http://manpagesfr.free.fr/man/man2/mmap.2.html">man</a> or directly the implementation in the linux kernel . And you can see that with this version, the emulation works perfectly üëå:</p>
<pre><code>[+] load 0x400000 - 0x401000
[+] load 0x7ff13371000 - 0x7ff1337e000
[+] load 0x7ff1337e000 - 0x7ff13383000
[+] load 0x7ff13383000 - 0x7ff13385000
[+] mem_start: 0x400000 mem_end: 0x7ff13385000
[+] mmap_address is : 0x7fffb7dd6000
open(/proc/self/exe, 0x0, 0o0) = 3
[+] open(/proc/self/exe, O_RDONLY, 0o0) = 3
[+] File Found: /proc/self/exe
lseek(3, 0x0, 0x2) = 0
lseek(3, 0x0, 0x2) = 79292
[+] log mmap2 - mmap2(0x0, 0x1e000, 0x3, 0x22, ffffffff, 0)
[+] log mmap2 - mmap2(0x0, 0x1e000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x345e6a56c000
[+] log mmap2 - addr range  : 0x345e6a56c000 - 0x345e6a58a000
mmap2(0x0, 0x1e000, 0x3, 0x22, 4294967295, 0) = 0x345e6a56c000
[+] mmap2_block is at 0x345e6a56c000 with a length of 0x1e000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT]
[+] 00400000 - 00401000 - r--    /mnt/p/leetness
[+] 7ff13371000 - 7ff1337e000 - r-x    /mnt/p/leetness
[+] 7ff1337e000 - 7ff13383000 - r--    /mnt/p/leetness
[+] 7ff13383000 - 7ff13385000 - rw-    /mnt/p/leetness
[+] 7ff13385000 - 7ff13387000 - rwx    hook mem
[+] 345e6a56c000 - 345e6a58a000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
lseek(3, 0x0, 0x0) = 0
lseek(3, 0x0, 0x0) = 0
read(3, 0x345e6a56c028, 0x135bc) = 79292
[+] log mmap2 - mmap2(0x0, 0xc01000, 0x3, 0x22, ffffffff, 0)
[+] log mmap2 - mmap2(0x0, 0xc01000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x3b475f9b2000
[+] log mmap2 - addr range  : 0x3b475f9b2000 - 0x3b47605b3000
mmap2(0x0, 0xc01000, 0x3, 0x22, 4294967295, 0) = 0x3b475f9b2000
[+] mmap2_block is at 0x3b475f9b2000 with a length of 0xc01000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT]
[+] 00400000 - 00401000 - r--    /mnt/p/leetness
[+] 7ff13371000 - 7ff1337e000 - r-x    /mnt/p/leetness
[+] 7ff1337e000 - 7ff13383000 - r--    /mnt/p/leetness
[+] 7ff13383000 - 7ff13385000 - rw-    /mnt/p/leetness
[+] 7ff13385000 - 7ff13387000 - rwx    hook mem
[+] 345e6a56c000 - 345e6a58a000 - rw-    [mapped]
[+] 3b475f9b2000 - 3b47605b3000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] log mmap2 - mmap2(0x400000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x400000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x0
[+] log mmap2 - mmap2(0x401000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x401000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x401000
[+] log mmap2 - addr range  : 0x401000 - 0x402000
mmap2(0x401000, 0x1000, 0x7, 0x32, 4294967295, 0) = 0x401000
[+] mmap2_block is at 0x401000 with a length of 0x1000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT]
[+] 00400000 - 00401000 - rwx    [mapped]
[+] 00401000 - 00402000 - rwx    [mapped]
[+] 7ff13371000 - 7ff1337e000 - r-x    /mnt/p/leetness
[+] 7ff1337e000 - 7ff13383000 - r--    /mnt/p/leetness
[+] 7ff13383000 - 7ff13385000 - rw-    /mnt/p/leetness
[+] 7ff13385000 - 7ff13387000 - rwx    hook mem
[+] 345e6a56c000 - 345e6a58a000 - rw-    [mapped]
[+] 3b475f9b2000 - 3b47605b3000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] log mmap2 - mmap2(0x402000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x402000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x402000
[+] log mmap2 - addr range  : 0x402000 - 0x403000
mmap2(0x402000, 0x1000, 0x7, 0x32, 4294967295, 0) = 0x402000
[+] mmap2_block is at 0x402000 with a length of 0x1000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT]
[+] 00400000 - 00401000 - rwx    [mapped]
[+] 00401000 - 00402000 - rwx    [mapped]
[+] 00402000 - 00403000 - rwx    [mapped]
[+] 7ff13371000 - 7ff1337e000 - r-x    /mnt/p/leetness
[+] 7ff1337e000 - 7ff13383000 - r--    /mnt/p/leetness
[+] 7ff13383000 - 7ff13385000 - rw-    /mnt/p/leetness
[+] 7ff13385000 - 7ff13387000 - rwx    hook mem
[+] 345e6a56c000 - 345e6a58a000 - rw-    [mapped]
[+] 3b475f9b2000 - 3b47605b3000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
write(1,402000,25) = 0
Could you get the flag ?
kurisu
read(0, 0x80000000de78, 0x1f) = 7
write(1,40203c,18) = 0
You lost THE GAME
exit(0) = 0
</code></pre><p>The binary is basically opening /proc/self/exe, getting the length of itself with lseek, mapping a lot of things and then is asking for a flag. And when the flag is bad it makes us loose to the <a href="https://en.wikipedia.org/wiki/The_Game_(mind_game)">game</a>.</p>
<h2 id="hooking--unpacking">Hooking &amp; Unpacking<a href="#hooking--unpacking" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now that we have the basics on qiling, we will begin to implement some unpacking techniques by hooking certain functions / syscall.</p>
<p>Firstly, according to the first rule described previously in <a href="#unpacking-thougths--algorithms">Unpacking, thougths &amp; algorithms</a>, we will record all the executable memory areas to add them in a list. It can be done by hooking syscalls like mprotect &amp; mmap. We hook these syscall like we&rsquo;ve done previously with sys_mmap. And each time we have to mmap / mprotect a memory area with the bit PROT_EXEC we save its length and it base address in a list. So we can get all the pages mmaped with the rights permissions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">mem_regions_exec <span style="color:#f92672">=</span> [] <span style="color:#75715e"># list of dic</span>
mem_regions <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_available</span>(ql, addr, size):
    <span style="color:#e6db74">&#39;&#39;&#39;
</span><span style="color:#e6db74">    The main function of is_available is to determine 
</span><span style="color:#e6db74">    whether the memory starting with addr and having a size of length can be used for allocation.
</span><span style="color:#e6db74">    If it can be allocated, returns True.
</span><span style="color:#e6db74">    If it cannot be allocated, it returns False.
</span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
    <span style="color:#66d9ef">try</span>:
        ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>map(addr, size)
    <span style="color:#66d9ef">except</span>:
        <span style="color:#66d9ef">return</span> False    

    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>unmap(addr, size)

    <span style="color:#66d9ef">return</span> True

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">local_hook</span>(ql, addr, size, prot) <span style="color:#f92672">-&gt;</span> int:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Records all the memory area mmaped / mprotected with the rights permissions
</span><span style="color:#e6db74">    If the area is executable it&#39;s added to mem_regions_exec
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    tmp_lst <span style="color:#f92672">=</span> [addr, size, prot]

    s <span style="color:#f92672">=</span> True

    <span style="color:#66d9ef">if</span> prot <span style="color:#f92672">&amp;</span> UC_PROT_EXEC:

        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] mapping with PROT_EXEC prot 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74"> - 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (addr, addr <span style="color:#f92672">+</span> size))

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(mem_regions_exec)):
            <span style="color:#66d9ef">if</span> tmp_lst[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> mem_regions_exec[i][<span style="color:#ae81ff">0</span>]:
                
                mem_regions_exec[i] <span style="color:#f92672">=</span> tmp_lst
                <span style="color:#75715e"># Get base address and sz</span>

                s <span style="color:#f92672">=</span> False
                <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">if</span> s:
            mem_regions_exec<span style="color:#f92672">.</span>append(tmp_lst)

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(mem_regions)):
        <span style="color:#66d9ef">if</span> tmp_lst[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> mem_regions[i][<span style="color:#ae81ff">0</span>]:
            
            mem_regions[i] <span style="color:#f92672">=</span> tmp_lst
            <span style="color:#75715e"># Update permissions</span>

            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0x0</span>

    mem_regions<span style="color:#f92672">.</span>append(tmp_lst)

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0x0</span>

<span style="color:#75715e"># ...</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mmap_c</span>(ql, mmap2_addr, mmap2_length, mmap2_prot, mmap2_flags, mmap2_fd, mmap2_pgoffset):

    <span style="color:#75715e"># ...</span>

    local_hook(ql, random_base_align, mmap2_length_align, mmap2_prot)

    <span style="color:#75715e"># ...</span>

<span style="color:#75715e"># ...</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ql_syscall_mprotect</span>(ql, mprotect_start, mprotect_len, mprotect_prot, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kw):
    regreturn <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    ql<span style="color:#f92672">.</span>nprint(<span style="color:#e6db74">&#34;mprotect(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">) = </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (mprotect_start, mprotect_len, mprotect_prot, regreturn))
    ql<span style="color:#f92672">.</span>dprint(D_INFO, <span style="color:#e6db74">&#34;[+] mprotect(0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">) = </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (
    mprotect_start, mprotect_len, mmap_prot_mapping(mprotect_prot), regreturn))

    base_align <span style="color:#f92672">=</span> ((mprotect_start <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>
    length_align <span style="color:#f92672">=</span> ((mprotect_len <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>

    ql<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>mem_protect(base_align, length_align, mprotect_prot)
    ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>add_mapinfo(base_align, base_align<span style="color:#f92672">+</span>length_align, mem_p<span style="color:#f92672">=</span>mprotect_prot, mem_info<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;[mprotect]&#34;</span>)

    local_hook(ql, base_align, length_align, mprotect_prot)

    ql<span style="color:#f92672">.</span>os<span style="color:#f92672">.</span>definesyscall_return(regreturn)
</code></pre></div><p>Now we have an exec_memory_area which contains all the executable areas. One thing we can do is dump the page each time it&rsquo;s written. It can be interesting in the case where the binary is unpacking something, jumping on, and rewrite a part of the same page with another shellcode to jump on this shellcode later. But if we do that we will dump a loooot of pages so it&rsquo;s not convenient. For our scenario, we will dump the executable pages mapped by the program each time the execution is transfered there. More precisely, each time the instruction pointer is in an executable memory area, we will print the instruction executed an add it in a trace. And the first time the execution jump on one of those pages, we will look for the most closest elf header in the memory compared to the target page. It will be effective only for the most basic packed binaries because of an elf header is useless for the execution it&rsquo;s often deleted. It&rsquo;s however mandatory for the parsing &amp; mapping part in the case described <a href="#code-injection--common-techniques">here</a>. For unpacking stubs it stays effective because most of the time the unpacking stub is just basically unpacking the packed code and jump on, without unmapping the elf header.</p>
<p>To do that, we need to hook each instruction to check if the execution is in one of our memory area that we&rsquo;ve registered as being mapped with executable permissions by the program. Qiling provide the hook_code(callback) function, which will call callback for each instruction executed with these arguments: callback(ql: object, addr: int, size: int). ql is the qiling instance, addr is the address of the instruction and size the length of this one. I&rsquo;ve also implemented a small cache for performances purposes. It looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_in_range</span>(addr) <span style="color:#f92672">-&gt;</span> bool:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Checks if an address is in the range of executable memeory area mapped by the process
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">for</span> area <span style="color:#f92672">in</span> mem_regions_exec:
            <span style="color:#66d9ef">if</span> addr <span style="color:#f92672">&gt;=</span> area[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">and</span> addr <span style="color:#f92672">&lt;=</span> area[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> area[<span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">return</span> False

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dump</span>(ql, addr):
    matchs <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x7f</span><span style="color:#e6db74">ELF&#34;</span>)
    <span style="color:#75715e"># All the matchs in the current virtual memory</span>

    average <span style="color:#f92672">=</span> {}

    <span style="color:#66d9ef">for</span> ar <span style="color:#f92672">in</span> matchs:
        <span style="color:#66d9ef">if</span> addr <span style="color:#f92672">&gt;</span> ar:
            <span style="color:#75715e"># If the address is next the match because it cannot be lower (it&#39;s the header) </span>
            
            average[ar] <span style="color:#f92672">=</span> addr <span style="color:#f92672">-</span> ar
            <span style="color:#75715e"># Get the offset</span>

    m_sorted <span style="color:#f92672">=</span> sorted(average, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: average<span style="color:#f92672">.</span>keys())
    <span style="color:#75715e"># Get the matchs the most closer to addr</span>

    addr_dmp <span style="color:#f92672">=</span> m_sorted[<span style="color:#ae81ff">0</span>]

    <span style="color:#75715e"># Here is a very quick parsing of the header to know what is the length of the binary </span>
    <span style="color:#75715e"># (the offset of the section header table plus its length)</span>

    shoff <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(addr_dmp <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">0x8</span>), <span style="color:#e6db74">&#34;little&#34;</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Section header offset : 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> shoff)

    len_section_headers <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(addr_dmp <span style="color:#f92672">+</span> <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">0x2</span>), <span style="color:#e6db74">&#34;little&#34;</span>) <span style="color:#f92672">*</span> int<span style="color:#f92672">.</span>from_bytes(ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(addr_dmp <span style="color:#f92672">+</span> <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">0x2</span>), <span style="color:#e6db74">&#34;little&#34;</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] length of the section headers : 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> len_section_headers)

    len_dmp <span style="color:#f92672">=</span> shoff <span style="color:#f92672">+</span> len_section_headers
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;[+] Final binary dumped : 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74"> - 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (addr_dmp, addr_dmp <span style="color:#f92672">+</span> len_dmp))

    dmp <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(addr_dmp, len_dmp)

    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;bin.u&#34;</span>, <span style="color:#e6db74">&#34;wb+&#34;</span>) <span style="color:#66d9ef">as</span> file_unpacked:
        <span style="color:#75715e"># Dump on the disk</span>
        file_unpacked<span style="color:#f92672">.</span>write(dmp)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_callback_</span>(ql, addr, size):
    <span style="color:#66d9ef">global</span> md, idx, pinst

    <span style="color:#75715e"># (addr &gt;&gt; 12) &lt;&lt; 12) is the base address of the page to which belongs addr</span>
    <span style="color:#66d9ef">if</span> ((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">in</span> c_m <span style="color:#f92672">or</span> addr <span style="color:#f92672">in</span> cache:
        <span style="color:#75715e"># If the address is already in the cache miss or in the cache it returns</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> is_in_range(((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>)):
        <span style="color:#75715e"># If it is not yet in the cache miss and that addr is not in a mapped area in PF_X</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;{} append to the cache&#34;</span><span style="color:#f92672">.</span>format(hex(((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>))))
        c_m<span style="color:#f92672">.</span>append(((addr <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>))
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">if</span> len(cache) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span>:
        <span style="color:#75715e"># cache for obfuscated instrcutions (to avoid loop repetitions)</span>
        cache<span style="color:#f92672">.</span>append(addr)
    <span style="color:#66d9ef">else</span>:
        cache[idx <span style="color:#f92672">%</span> <span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> addr
        idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

    pinst <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#75715e"># Number of unpacked instructions executed </span>

    <span style="color:#66d9ef">if</span> pinst <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x1</span>:
        dump(ql, addr)

    ins <span style="color:#f92672">=</span> ql<span style="color:#f92672">.</span>mem<span style="color:#f92672">.</span>read(addr, size)
    <span style="color:#75715e"># We read the raw bytes for the instruction</span>

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> md<span style="color:#f92672">.</span>disasm(ins, addr):
        <span style="color:#75715e"># We disassemble it</span>
        insnt <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;{} : {} {}&#34;</span><span style="color:#f92672">.</span>format(hex(i<span style="color:#f92672">.</span>address), i<span style="color:#f92672">.</span>mnemonic, i<span style="color:#f92672">.</span>op_str)

        <span style="color:#66d9ef">print</span>(insnt)

        <span style="color:#66d9ef">if</span> insnt <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> trace:
            <span style="color:#75715e"># append meta datas for the instruction in the trace</span>
            trace<span style="color:#f92672">.</span>append(insnt)

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:

    <span style="color:#75715e"># ...</span>

    ql_<span style="color:#f92672">.</span>hook_code(_callback_)

    <span style="color:#75715e"># ...</span>
</code></pre></div><p>I think that the comments are clear enough so now let&rsquo;s put all together and launch it !!</p>
<pre><code>[+] load 0x400000 - 0x401000
[+] load 0x7ff13371000 - 0x7ff1337e000
[+] load 0x7ff1337e000 - 0x7ff13383000
[+] load 0x7ff13383000 - 0x7ff13385000
[+] mem_start: 0x400000 mem_end: 0x7ff13385000
[+] mmap_address is : 0x7fffb7dd6000
0x7ff13371000 append to the cache
0x7ff13372000 append to the cache
open(/proc/self/exe, 0x0, 0o0) = 3
[+] open(/proc/self/exe, O_RDONLY, 0o0) = 3
[+] File Found: /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/proc/self/exe
lseek(3, 0x0, 0x2) = 0
lseek(3, 0x0, 0x2) = 79292
[+] log mmap2 - mmap2(0x0, 0x1e000, 0x3, 0x22, ffffffff, 0)
[+] log mmap2 - mmap2(0x0, 0x1e000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x2489f63bf000
[+] log mmap2 - addr range  : 0x2489f63bf000 - 0x2489f63dd000
mmap2(0x0, 0x1e000, 0x3, 0x22, 4294967295, 0) = 0x2489f63bf000
[+] mmap2_block is at 0x2489f63bf000 with a length of 0x1e000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00400000 - 00401000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13371000 - 7ff1337e000 - r-x    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff1337e000 - 7ff13383000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13383000 - 7ff13385000 - rw-    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13385000 - 7ff13387000 - rwx    [hook_mem] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 2489f63bf000 - 2489f63dd000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] ffffffffff600000 - ffffffffff601000 - rwx    [vsyscall]
lseek(3, 0x0, 0x0) = 0
lseek(3, 0x0, 0x0) = 0
read(3, 0x2489f63bf028, 0x135bc) = 79292
0x7ff13373000 append to the cache
0x7ff13375000 append to the cache
0x7ff13374000 append to the cache
0x7ff13376000 append to the cache
0x7ff1337c000 append to the cache
0x7ff1337a000 append to the cache
0x7ff1337d000 append to the cache
[+] log mmap2 - mmap2(0x0, 0xc01000, 0x3, 0x22, ffffffff, 0)
[+] log mmap2 - mmap2(0x0, 0xc01000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x19f699ed4000
[+] log mmap2 - addr range  : 0x19f699ed4000 - 0x19f69aad5000
mmap2(0x0, 0xc01000, 0x3, 0x22, 4294967295, 0) = 0x19f699ed4000
[+] mmap2_block is at 0x19f699ed4000 with a length of 0xc01000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00400000 - 00401000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13371000 - 7ff1337e000 - r-x    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff1337e000 - 7ff13383000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13383000 - 7ff13385000 - rw-    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13385000 - 7ff13387000 - rwx    [hook_mem] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 19f699ed4000 - 19f69aad5000 - rw-    [mapped]
[+] 2489f63bf000 - 2489f63dd000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] ffffffffff600000 - ffffffffff601000 - rwx    [vsyscall]
0x7ff13377000 append to the cache
0x7ff13378000 append to the cache
0x7ff13379000 append to the cache
[+] log mmap2 - mmap2(0x400000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x400000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x0
[+] mapping with PROT_EXEC prot 0x400000 - 0x401000
[+] log mmap2 - mmap2(0x401000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x401000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x401000
[+] log mmap2 - addr range  : 0x401000 - 0x402000
mmap2(0x401000, 0x1000, 0x7, 0x32, 4294967295, 0) = 0x401000
[+] mmap2_block is at 0x401000 with a length of 0x1000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00400000 - 00401000 - rwx    [mapped] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00401000 - 00402000 - rwx    [mapped] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13371000 - 7ff1337e000 - r-x    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff1337e000 - 7ff13383000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13383000 - 7ff13385000 - rw-    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13385000 - 7ff13387000 - rwx    [hook_mem] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 19f699ed4000 - 19f69aad5000 - rw-    [mapped]
[+] 2489f63bf000 - 2489f63dd000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] ffffffffff600000 - ffffffffff601000 - rwx    [vsyscall]
[+] mapping with PROT_EXEC prot 0x401000 - 0x402000
[+] log mmap2 - mmap2(0x402000, 0x1000, 0x7, 0x32, ffffffff, 0)
[+] log mmap2 - mmap2(0x402000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, ffffffff, 0)
[+] log mmap2 - return addr : 0x402000
[+] log mmap2 - addr range  : 0x402000 - 0x403000
mmap2(0x402000, 0x1000, 0x7, 0x32, 4294967295, 0) = 0x402000
[+] mmap2_block is at 0x402000 with a length of 0x1000
[+] Start      End        Perm.  Path
[+] 00003000 - 00004000 - rwx    [GDT] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00400000 - 00401000 - rwx    [mapped] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00401000 - 00402000 - rwx    [mapped] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 00402000 - 00403000 - rwx    [mapped] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13371000 - 7ff1337e000 - r-x    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff1337e000 - 7ff13383000 - r--    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13383000 - 7ff13385000 - rw-    /media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 7ff13385000 - 7ff13387000 - rwx    [hook_mem] (/media/nasm/7044d811-e1cd-4997-97d5-c08072ce9497/Downloads/qiling/examples/rootfs/x8664_linux/bin/leetness)
[+] 19f699ed4000 - 19f69aad5000 - rw-    [mapped]
[+] 2489f63bf000 - 2489f63dd000 - rw-    [mapped]
[+] 7ffffffde000 - 80000000e000 - rwx    [stack]
[+] ffffffffff600000 - ffffffffff601000 - rwx    [vsyscall]
[+] mapping with PROT_EXEC prot 0x402000 - 0x403000
[+] Section header offset : 0x20e8
[+] length of the section headers : 0x1c0
[+] Final binary dumped : 0x400000 - 0x4022a8
0x401000 : push rbx
0x401001 : mov edx, 0x19
0x401006 : mov edi, 1
0x40100b : lea rsi, [rip + 0xfee]
0x401012 : sub rsp, 0x20
0x401016 : call 0x4010f0
0x4010f0 : mov eax, 1
0x4010f5 : syscall 
write(1,402000,25) = 0
Could you get the flag?
0x4010f7 : ret 
0x40101b : mov rbx, rsp
0x40101e : mov edx, 0x1f
0x401023 : xor edi, edi
0x401025 : mov rsi, rbx
0x401028 : call 0x4010d0
0x4010d0 : xor eax, eax
0x4010d2 : syscall 
kurisu
read(0, 0x80000000de68, 0x1f) = 7
0x4010d4 : ret 
0x40102d : sub rax, 1
0x401031 : mov byte ptr [rsp + rax], 0
0x401035 : test rax, rax
0x401038 : jle 0x40108d
0x40103a : xor edx, edx
0x40103c : mov ecx, 1
0x401041 : lea rdi, [rip + 0xfd2]
0x401048 : nop dword ptr [rax + rax]
0x401050 : movzx esi, byte ptr [rdi + rdx]
0x401054 : cmp byte ptr [rbx + rdx], sil
0x401058 : sete sil
0x40105c : add rdx, 1
0x401060 : movzx esi, sil
0x401064 : and ecx, esi
0x401066 : cmp rdx, rax
0x401069 : jne 0x401050
0x40106b : cmp ecx, 1
0x40106e : je 0x40108d
0x401070 : mov edx, 0x12
0x401075 : lea rsi, [rip + 0xfc0]
0x40107c : mov edi, 1
0x401081 : call 0x4010f0
write(1,40203c,18) = 0
You lost THE GAME
0x401086 : xor edi, edi
0x401088 : call 0x4010e0
0x4010e0 : mov rax, 0x3c
0x4010e7 : syscall 
exit(0) = 0
$ file bin.u
bin.u: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
$ strings bin.u
ijZ7K
Could you get the flag ?
flag{unp4ck_1s_fun}
Gr33tz d00dz
You lost THE GAME
$ chmod +x bin.u &amp;&amp; ./bin.u &lt; &lt;(python -c 'print &quot;flag{unp4ck_1s_fun}&quot;')
Could you get the flag ?
Gr33tz d00dz
</code></pre><p>Awesome !!!! We&rsquo;ve finished to develop our automatic unpacker with qiling ! And we found the password by using strings on the unpacked binary üôÇ. The final code looks like this:</p>
<script src="https://gist.github.com/n4sm/8849382bdeab8bae1ef0557c61aa2fcd.js"></script>
<p>The code is available on <a href="https://gist.github.com/n4sm/8849382bdeab8bae1ef0557c61aa2fcd">github gist</a>. And you can get the binary <a href="https://kernemporium.github.io/articles/en/auto_unpacking/leetness">here</a>.</p>
<h2 id="summary">Summary<a href="#summary" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>To summarize, I&rsquo;ve talked about a few techniques of packing and we&rsquo;ve seen how to fight against them. The reliability of the PoC that I&rsquo;ve developped depends on your target. But in all the cases, I think that the better technique stays to hook sys_mmap and sys_mprotect to record all the memory areas mapped / protected by the program in PROT_EXEC. Next the question is what to do with that (looking for an elf header in the memory, dump the page each time an executable page is written &hellip;).</p>
<p>Thanks for reading and I hope that it has been interesting ;). If you have any questions dm me on <a href="https://tiwtter.com/nasm_re">twitter</a> or ask on my <a href="https://0xthxmxs.github.io/discord">discord server</a>.</p>
<p>~ cheers, nasm</p>

      </div></div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>¬© linKERN Emporium 2021</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


  <script src="/assets/languageSelector.js"></script>






  
</div>

</body>
</html>
